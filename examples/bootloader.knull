// =============================================================================
// BOOTLOADER - THE BAREMETAL
// =============================================================================
// A simple bootloader stub running in 16-bit Real Mode
// This demonstrates Knull's ability to target bare metal.

module main

// =============================================================================
// BOOTLOADER (16-bit Real Mode)
// =============================================================================
// This code would be compiled to a 16-bit binary and placed in the 
// boot sector (0x7C00). It demonstrates:
// - Inline assembly
// - Direct memory access
// - BIOS interrupts
// - Bare metal programming

unsafe fn boot_16() {
    // =============================================================================
    // REAL MODE BOOT SECTOR CODE
    // =============================================================================
    
    asm intel {
        // Disable interrupts
        "cli"
        
        // Set up segment registers
        "xor ax, ax"
        "mov ds, ax"
        "mov es, ax"
        "mov ss, ax"
        
        // Set up stack
        "mov sp, 0x7C00"
        
        // Enable A20 line (required for accessing memory above 1MB)
        "in al, 0x92"
        "or al, 2"
        "out 0x92, al"
        
        // Switch to protected mode
        "lgdt [gdt_descriptor]"
        "mov eax, cr0"
        "or eax, 1"
        "mov cr0, eax"
        
        // Far jump to enable 32-bit mode
        "jmp 0x08:protected_mode_start"
    }
    
    // =============================================================================
    // GDT (Global Descriptor Table)
    // =============================================================================
    
    // Null descriptor
    // [0] = 0x00000000, 0x00000000
    
    // Code segment descriptor
    // Base: 0x00000000
    // Limit: 0xFFFFF (4GB)
    // Access: 0x9A (present, ring 0, executable, readable)
    // Flags: 0x0C (granularity = 4KB, 32-bit)
    let gdt_code = [
        0xFF, 0xFF,  // Limit low
        0x00,        // Base low
        0x9A,       // Access byte
        0xCF,       // Flags + Limit high
        0x00,        // Base high
    ]
    
    // Data segment descriptor
    // Access: 0x92 (present, ring 0, writable)
    let gdt_data = [
        0xFF, 0xFF,
        0x00,
        0x92,
        0xCF,
        0x00,
    ]
    
    // GDT descriptor (6 bytes)
    // Size (2 bytes) + Address (4 bytes)
    let gdt_descriptor = [
        0x17,        // Size - 1 (23 bytes - 1)
        0x00,        // Address low
        0x00,
        0x00,
    ]
    
    // =============================================================================
    // PROTECTED MODE (32-bit)
    // =============================================================================
    
    asm intel {
        "protected_mode_start:"
        // Set up segment registers
        "mov ax, 0x10"  // Data segment selector
        "mov ds, ax"
        "mov es, ax"
        "mov fs, ax"
        "mov gs, ax"
        "mov ss, ax"
        
        // Enable FPU
        "fninit"
        
        // Set up page tables (simple identity mapping)
        // This is a simplified page table setup
        "mov eax, 0x00000000"
        "mov cr3, eax"
        
        // Enable PAE (Physical Address Extension)
        "mov eax, cr4"
        "or eax, 0x20"
        "mov cr4, eax"
        
        // Enable long mode (LM bit in EFER)
        "mov ecx, 0xC0000080"
        "rdmsr"
        "or eax, 0x100"
        "wrmsr"
        
        // Enable paging
        "mov eax, cr0"
        "or eax, 0x80000000"
        "mov cr0, eax"
        
        // Jump to 64-bit mode
        "jmp 0x08:long_mode_start"
    }
    
    // =============================================================================
    // LONG MODE (64-bit)
    // =============================================================================
    
    asm intel {
        "long_mode_start:"
        // Set up 64-bit segment registers
        "mov ax, 0"
        "mov ds, ax"
        "mov es, ax"
        "mov fs, ax"
        "mov gs, ax"
        "mov ss, ax"
        
        // Clear 64-bit registers
        "xor rax, rax"
        "xor rbx, rbx"
        "xor rcx, rdx"
        "xor rsi, rsi"
        "xor rdi, rdp"
        "xor rbp, rbp"
        "xor r8, r8"
        "xor r9, r9"
        "xor r10, r10"
        "xor r11, r11"
        "xor r12, r12"
        "xor r13, r13"
        "xor r14, r14"
        "xor r15, r15"
    }
    
    // =============================================================================
    // VGA TEXT MODE OUTPUT
    // =============================================================================
    
    // VGA memory starts at 0xB8000
    // Each character is 2 bytes: (character, attribute)
    // Attribute: foreground (4 bits) + background (4 bits)
    // 0x0F = white on black
    
    let VGA_MEMORY: *mut u16 = 0xB8000 as *mut u16
    let VGA_WIDTH: usize = 80
    let VGA_HEIGHT: usize = 25
    
    // Write "KNULL" to the screen
    unsafe {
        let message = "KNULL OS".to_string()
        let attrs = 0x0F00  // White on black
        
        for (i, c) in message.chars().enumerate() {
            let offset = i as isize
            VGA_MEMORY.offset(offset).write(c as u16 | attrs)
        }
        
        // Add blinking "BOOT" indicator
        let boot_offset = 80  // Second line
        let boot_msg = "BOOTING...".to_string()
        
        for (i, c) in boot_msg.chars().enumerate() {
            let offset = (boot_offset + i) as isize
            VGA_MEMORY.offset(offset).write(c as u16 | 0x0A00)  // Green
        }
    }
    
    // =============================================================================
    // SIMPLE KERNEL LOADER
    // =============================================================================
    
    // In a real bootloader, we would:
    // 1. Read kernel from disk (BIOS interrupts 0x13)
    // 2. Set up memory map
    // 3. Jump to kernel entry point
    
    // For this example, we'll just halt
    
    loop {
        // Halt the CPU
        asm intel {
            "hlt"
        }
    }
}

// =============================================================================
// ALTERNATIVE: UEFI BOOT (64-bit)
// =============================================================================

unsafe fn boot_uefi() {
    // UEFI boot is simpler - we're already in 64-bit mode
    
    // Get EFI system table (passed in registers by firmware)
    // In practice, this would be provided by the bootloader
    
    // Simple text output using UEFI console
    // This is pseudocode - real UEFI requires calling boot services
    
    // Allocate memory for page tables
    // Set up identity mapping for all physical memory
    // Enable paging
    // Jump to kernel
}

// =============================================================================
// KERNEL MAIN (64-bit Long Mode)
// =============================================================================

unsafe fn kernel_main() {
    // =============================================================================
    // KERNEL INITIALIZATION
    // =============================================================================
    
    // Initialize the GDT (done by bootloader)
    // Initialize IDT (Interrupt Descriptor Table)
    // Initialize PIC (Programmable Interrupt Controller)
    // Initialize PIT (Programmable Interval Timer)
    // Initialize APIC (Advanced PIC)
    // Initialize memory management
    
    // =============================================================================
    // PHYSICAL MEMORY MANAGER
    // =============================================================================
    
    // Simple bitmap-based allocator
    let memory_map_base: *mut u8 = 0x100000 as *mut u8  // Start at 1MB
    let memory_map_size: usize = 128 * 1024 * 1024 / 8  // 128MB
    
    // Initialize bitmap (set all as free)
    for i in 0..memory_map_size {
        memory_map_base.offset(i).write(0xFF)
    }
    
    // Mark first few MB as used (kernel, boot info, etc.)
    for i in 0..(16 * 1024 * 1024 / 4096) {
        memory_map_base.offset(i / 8).write(memory_map_base.offset(i / 8).read() & !(1 << (i % 8)))
    }
    
    // =============================================================================
    // PAGE FRAME ALLOCATOR
    // =============================================================================
    
    // Allocate a page (4KB)
    fn allocate_frame() -> *mut u8 {
        // Find first free frame
        for i in 0..memory_map_size {
            let byte = memory_map_base.offset(i).read()
            if byte != 0 {
                // Find first set bit
                for j in 0..8 {
                    if byte & (1 << j) != 0 {
                        // Mark as used
                        memory_map_base.offset(i).write(byte & !(1 << j))
                        
                        // Return physical address
                        return ((i * 8 + j) * 4096) as *mut u8
                    }
                }
            }
        }
        
        // No memory available
        0 as *mut u8
    }
    
    // Free a page
    fn free_frame(frame: *mut u8) {
        let frame_num = frame as usize / 4096
        let byte_idx = frame_num / 8
        let bit_idx = frame_num % 8
        
        memory_map_base.offset(byte_idx).write(
            memory_map_base.offset(byte_idx).read() | (1 << bit_idx)
        )
    }
    
    // =============================================================================
    // KERNEL HEAP
    // =============================================================================
    
    // Simple slab allocator for kernel objects
    let heap_start: *mut u8 = allocate_frame()
    let heap_end = heap_start.offset(16 * 1024 * 1024)  // 16MB heap
    
    // =============================================================================
    // INTERRUPT DESCRIPTOR TABLE
    // =============================================================================
    
    // IDT entry structure (64-bit)
    struct IdtEntry {
        offset_low: u16,
        selector: u16,
        ist: u8,
        type_attr: u8,
        offset_mid: u16,
        offset_high: u32,
        reserved: u32,
    }
    
    // Set up IDT entries for:
    // - Divide by zero (0)
    // - Page fault (14)
    // - Keyboard (33)
    // - Timer (32)
    // - Syscall (128)
    
    let idt: *mut IdtEntry = allocate_frame() as *mut IdtEntry
    
    // Register interrupt handlers
    fn set_idt_entry(entry: *mut IdtEntry, handler: fn()) {
        let addr = handler as u64
        
        entry.write(IdtEntry {
            offset_low: (addr & 0xFFFF) as u16,
            selector: 0x08,  // Kernel code segment
            ist: 0,
            type_attr: 0x8E,  // Present, Ring 0, 64-bit interrupt gate
            offset_mid: ((addr >> 16) & 0xFFFF) as u16,
            offset_high: ((addr >> 32) & 0xFFFFFFFF) as u32,
            reserved: 0,
        })
    }
    
    // =============================================================================
    // KEYBOARD DRIVER
    // =============================================================================
    
    // PS/2 Keyboard I/O ports
    const KEYBOARD_DATA_PORT: u16 = 0x60
    const KEYBOARD_STATUS_PORT: u16 = 0x64
    
    // Key map (simplified US QWERTY)
    let keymap = [
        // Normal shift
        "...............1..23456789.0-=..qwertyuiop[]..asdfghjkl;'..zxcvbnm,./",
        // Shifted
        "...............!@#$%^&*()_+..QWERTYUIOP{}..ASDFGHJKL:\"..ZXCVBNM<>?",
    ]
    
    fn read_keyboard() -> option<(char, bool)> {
        // Check if data available
        let status = inb(KEYBOARD_STATUS_PORT)
        if status & 1 == 0 {
            return None
        }
        
        let scancode = inb(KEYBOARD_DATA_PORT) as u8
        
        // Handle special keys
        if scancode == 0x2A || scancode == 0x36 {
            return None  // Shift key
        }
        
        // Convert to ASCII
        if scancode < keymap[0].len() as u8 {
            let shifted = false  // Would check shift state
            let c = keymap[shifted as usize][scancode as usize]
            if c != '.' {
                return Some((c, shifted))
            }
        }
        
        None
    }
    
    // =============================================================================
    // SIMPLE SHELL
    // =============================================================================
    
    println "Knull OS v1.0"
    println "Type 'help' for commands"
    println ""
    
    loop {
        print "$ "
        
        let command = read_line()
        
        match command.trim() {
            "help" => {
                println "Available commands:"
                println "  help   - Show this help"
                println "  echo   - Echo text"
                println "  clear  - Clear screen"
                println "  reboot - Reboot system"
                println "  halt   - Halt system"
            }
            "echo" => {
                if let Some(text) = command.get(5..) {
                    println text
                }
            }
            "clear" => {
                // Clear VGA screen
                unsafe {
                    for i in 0..(80 * 25) {
                        VGA_MEMORY.offset(i).write(0x0F00)  // Space with white on black
                    }
                }
            }
            "reboot" => {
                // Reboot via keyboard controller
                unsafe {
                    outb(0x64, 0xFE)  // Reset CPU
                }
            }
            "halt" => {
                println "System halted."
                loop {
                    asm intel { "hlt" }
                }
            }
            "" => {}
            _ => {
                println "Unknown command: {}", command
            }
        }
    }
}

// =============================================================================
// I/O PORT ACCESS (INLINE ASM)
// =============================================================================

fn inb(port: u16) -> u8 {
    let result: u8
    unsafe {
        asm intel {
            "mov dx, ${0}"
            "in al, dx"
            : "=al"(result)
            :
            : "dx"
        }
    }
    result
}

fn outb(port: u16, value: u8) {
    unsafe {
        asm intel {
            "mov dx, ${0}"
            "mov al, ${1}"
            "out dx, al"
            :
            : "r"(port as u32), "r"(value)
            : "dx", "al"
        }
    }
}

// =============================================================================
// MAIN ENTRY POINT
// =============================================================================

fn main() {
    println "Knull Bare Metal Bootloader"
    println "==========================="
    println ""
    println "This code demonstrates Knull's ability to:"
    println "  1. Write inline assembly (Intel syntax)"
    println "  2. Operate in 16-bit, 32-bit, and 64-bit modes"
    println "  3. Directly access hardware I/O ports"
    println "  4. Compile to bare metal without OS dependencies"
    println ""
    println "For actual boot, compile to 16-bit binary and place"
    println "in boot sector (0x7C00) or use UEFI."
}

// =============================================================================
// IMPLEMENTATION NOTES
// =============================================================================
//
// This bootloader demonstrates Knull's "God Mode" capabilities:
//
// 1. UNSAFE BLOCKS: Required for inline assembly, raw pointer
//    access, and I/O port operations.
//
// 2. INLINE ASSEMBLY: Intel syntax for x86/x86_64. Supports
//    all modern CPU features including Long Mode (64-bit).
//
// 3. DIRECT MEMORY ACCESS: Writing to VGA memory at 0xB8000,
//    setting up GDT, IDT, page tables.
//
// 4. ZERO-COST ABSTRACTIONS: High-level Rust-like syntax compiles
//    down to minimal machine code.
//
// 5. CROSS-COMPILATION: Can target any architecture from a single
//    host system.
//
// This is the ultimate demonstration of Knull's power:
// from beginner-friendly scripts to bare-metal operating systems,
// all with one unified language.
//
// =============================================================================
// BOOT PROCESS SUMMARY
// =============================================================================
//
// 1. BIOS/UEFI loads boot sector at 0x7C00
// 2. Real Mode (16-bit): Set up GDT, switch to Protected Mode
// 3. Protected Mode (32-bit): Set up page tables, switch to Long Mode
// 4. Long Mode (64-bit): Initialize kernel, start shell
// 5. User interacts via simple command line
//
// The same language that writes web servers and compilers can
// write bootloaders. That is the power of Knull.
// =============================================================================

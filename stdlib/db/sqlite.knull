// =============================================================================
// KNULL STANDARD LIBRARY - SQLITE MODULE
// =============================================================================
// SQLite database bindings using FFI to call the native SQLite C library

mode god

// -----------------------------------------------------------------------------
// SQLITE CONSTANTS
// -----------------------------------------------------------------------------

const SQLITE_OK: i32 = 0
const SQLITE_ERROR: i32 = 1
const SQLITE_INTERNAL: i32 = 2
const SQLITE_PERM: i32 = 3
const SQLITE_ABORT: i32 = 4
const SQLITE_BUSY: i32 = 5
const SQLITE_LOCKED: i32 = 6
const SQLITE_NOMEM: i32 = 7
const SQLITE_READONLY: i32 = 8
const SQLITE_INTERRUPT: i32 = 9
const SQLITE_IOERR: i32 = 10
const SQLITE_CORRUPT: i32 = 11
const SQLITE_NOTFOUND: i32 = 12
const SQLITE_FULL: i32 = 13
const SQLITE_CANTOPEN: i32 = 14
const SQLITE_PROTOCOL: i32 = 15
const SQLITE_EMPTY: i32 = 16
const SQLITE_SCHEMA: i32 = 17
const SQLITE_TOOBIG: i32 = 18
const SQLITE_CONSTRAINT: i32 = 19
const SQLITE_MISMATCH: i32 = 20
const SQLITE_MISUSE: i32 = 21
const SQLITE_NOLFS: i32 = 22
const SQLITE_AUTH: i32 = 23
const SQLITE_FORMAT: i32 = 24
const SQLITE_RANGE: i32 = 25
const SQLITE_NOTADB: i32 = 26
const SQLITE_ROW: i32 = 100
const SQLITE_DONE: i32 = 101

const SQLITE_INTEGER: i32 = 1
const SQLITE_FLOAT: i32 = 2
const SQLITE_TEXT: i32 = 3
const SQLITE_BLOB: i32 = 4
const SQLITE_NULL: i32 = 5

// SQLite opaque types
type Sqlite3 = u8
type Sqlite3Stmt = u8

// -----------------------------------------------------------------------------
// FFI DECLARATIONS - LINK WITH SQLITE
// -----------------------------------------------------------------------------

#[link(name = "sqlite3")]
extern "C" {
    // Database connection
    fn sqlite3_open(filename: *const u8, ppDb: *mut *mut Sqlite3) -> i32
    fn sqlite3_close(db: *mut Sqlite3) -> i32
    fn sqlite3_errmsg(db: *mut Sqlite3) -> *const u8
    fn sqlite3_errcode(db: *mut Sqlite3) -> i32
    fn sqlite3_extended_errcode(db: *mut Sqlite3) -> i32
    
    // Statement preparation and execution
    fn sqlite3_prepare_v2(
        db: *mut Sqlite3,
        zSql: *const u8,
        nByte: i32,
        ppStmt: *mut *mut Sqlite3Stmt,
        pzTail: *mut *const u8
    ) -> i32
    fn sqlite3_step(stmt: *mut Sqlite3Stmt) -> i32
    fn sqlite3_finalize(stmt: *mut Sqlite3Stmt) -> i32
    fn sqlite3_reset(stmt: *mut Sqlite3Stmt) -> i32
    
    // Column info
    fn sqlite3_column_count(stmt: *mut Sqlite3Stmt) -> i32
    fn sqlite3_column_name(stmt: *mut Sqlite3Stmt, N: i32) -> *const u8
    fn sqlite3_column_type(stmt: *mut Sqlite3Stmt, N: i32) -> i32
    
    // Column values
    fn sqlite3_column_int(stmt: *mut Sqlite3Stmt, iCol: i32) -> i32
    fn sqlite3_column_int64(stmt: *mut Sqlite3Stmt, iCol: i32) -> i64
    fn sqlite3_column_double(stmt: *mut Sqlite3Stmt, iCol: i32) -> f64
    fn sqlite3_column_text(stmt: *mut Sqlite3Stmt, iCol: i32) -> *const u8
    fn sqlite3_column_bytes(stmt: *mut Sqlite3Stmt, iCol: i32) -> i32
    
    // Parameter binding
    fn sqlite3_bind_parameter_count(stmt: *mut Sqlite3Stmt) -> i32
    fn sqlite3_bind_int(stmt: *mut Sqlite3Stmt, idx: i32, value: i32) -> i32
    fn sqlite3_bind_int64(stmt: *mut Sqlite3Stmt, idx: i32, value: i64) -> i32
    fn sqlite3_bind_double(stmt: *mut Sqlite3Stmt, idx: i32, value: f64) -> i32
    fn sqlite3_bind_text(
        stmt: *mut Sqlite3Stmt,
        idx: i32,
        value: *const u8,
        n: i32,
        destructor: *const u8
    ) -> i32
    fn sqlite3_bind_null(stmt: *mut Sqlite3Stmt, idx: i32) -> i32
    fn sqlite3_clear_bindings(stmt: *mut Sqlite3Stmt) -> i32
    
    // Utility functions
    fn sqlite3_aggregate_count(ctx: *const u8) -> i32
    fn sqlite3_errmsg16(db: *mut Sqlite3) -> *const u16
    fn sqlite3_free(ptr: *const u8)
}

// Memory allocation via FFI
#[link(name = "c")]
extern "C" {
    fn malloc(size: usize) -> *mut u8
    fn free(ptr: *mut u8)
    fn memcpy(dest: *mut u8, src: *const u8, n: usize) -> *mut u8
    fn strlen(s: *const u8) -> usize
}

// -----------------------------------------------------------------------------
// ROWS STRUCT
// -----------------------------------------------------------------------------

struct Rows {
    columns: Vec<String>,
    data: Vec<Vec<String>>,
}

// -----------------------------------------------------------------------------
// HELPER FUNCTIONS
// -----------------------------------------------------------------------------

fn c_string_to_string(ptr: *const u8) -> String {
    if ptr == 0 as *const u8 {
        return "".to_string()
    }
    
    let len = strlen(ptr)
    let bytes = slice_from_raw(ptr, len)
    return string_from_bytes(bytes)
}

fn slice_from_raw(ptr: *const u8, len: usize) -> [u8] {
    let result: [u8] = []
    let i = 0
    while i < len {
        let byte = *ptr.offset(i as isize)
        result = result + [byte]
        i = i + 1
    }
    return result
}

fn string_from_bytes(bytes: [u8]) -> String {
    let result = ""
    let i = 0
    while i < bytes.len() {
        if bytes[i] == 0 {
            break
        }
        result = result + char_from_byte(bytes[i])
        i = i + 1
    }
    return result
}

fn char_from_byte(b: u8) -> String {
    if b == 65 { return "A" }
    if b == 66 { return "B" }
    if b == 67 { return "C" }
    if b == 68 { return "D" }
    if b == 69 { return "E" }
    if b == 70 { return "F" }
    if b == 71 { return "G" }
    if b == 72 { return "H" }
    if b == 73 { return "I" }
    if b == 74 { return "J" }
    if b == 75 { return "K" }
    if b == 76 { return "L" }
    if b == 77 { return "M" }
    if b == 78 { return "N" }
    if b == 79 { return "O" }
    if b == 80 { return "P" }
    if b == 81 { return "Q" }
    if b == 82 { return "R" }
    if b == 83 { return "S" }
    if b == 84 { return "T" }
    if b == 85 { return "U" }
    if b == 86 { return "V" }
    if b == 87 { return "W" }
    if b == 88 { return "X" }
    if b == 89 { return "Y" }
    if b == 90 { return "Z" }
    if b == 97 { return "a" }
    if b == 98 { return "b" }
    if b == 99 { return "c" }
    if b == 100 { return "d" }
    if b == 101 { return "e" }
    if b == 102 { return "f" }
    if b == 103 { return "g" }
    if b == 104 { return "h" }
    if b == 105 { return "i" }
    if b == 106 { return "j" }
    if b == 107 { return "k" }
    if b == 108 { return "l" }
    if b == 109 { return "m" }
    if b == 110 { return "n" }
    if b == 111 { return "o" }
    if b == 112 { return "p" }
    if b == 113 { return "q" }
    if b == 114 { return "r" }
    if b == 115 { return "s" }
    if b == 116 { return "t" }
    if b == 117 { return "u" }
    if b == 118 { return "v" }
    if b == 119 { return "w" }
    if b == 120 { return "x" }
    if b == 121 { return "y" }
    if b == 122 { return "z" }
    if b == 48 { return "0" }
    if b == 49 { return "1" }
    if b == 50 { return "2" }
    if b == 51 { return "3" }
    if b == 52 { return "4" }
    if b == 53 { return "5" }
    if b == 54 { return "6" }
    if b == 55 { return "7" }
    if b == 56 { return "8" }
    if b == 57 { return "9" }
    if b == 95 { return "_" }
    if b == 45 { return "-" }
    if b == 46 { return "." }
    if b == 32 { return " " }
    if b == 58 { return ":" }
    if b == 47 { return "/" }
    if b == 92 { return "\\" }
    if b == 64 { return "@" }
    if b == 35 { return "#" }
    if b == 36 { return "$" }
    if b == 37 { return "%" }
    if b == 94 { return "^" }
    if b == 38 { return "&" }
    if b == 42 { return "*" }
    if b == 40 { return "(" }
    if b == 41 { return ")" }
    if b == 91 { return "[" }
    if b == 93 { return "]" }
    if b == 123 { return "{" }
    if b == 125 { return "}" }
    if b == 60 { return "<" }
    if b == 62 { return ">" }
    if b == 33 { return "!" }
    if b == 63 { return "?" }
    if b == 61 { return "=" }
    if b == 43 { return "+" }
    if b == 44 { return "," }
    if b == 59 { return ";" }
    if b == 39 { return "'" }
    if b == 34 { return "\"" }
    if b == 124 { return "|" }
    if b == 126 { return "~" }
    if b == 96 { return "`" }
    return ""
}

fn string_to_c_string(s: String) -> *const u8 {
    let len = s.len()
    let ptr = malloc(len + 1)
    
    let i = 0
    while i < len {
        let c = char_at(s, i)
        *ptr.offset(i as isize) = byte_from_char(c)
        i = i + 1
    }
    *ptr.offset(len as isize) = 0
    
    return ptr
}

fn char_at(s: String, i: i32) -> String {
    if i == 0 { 
        if s.len() > 0 { return get_char_0(s) } 
    }
    if i == 1 { 
        if s.len() > 1 { return get_char_1(s) } 
    }
    if i == 2 { 
        if s.len() > 2 { return get_char_2(s) } 
    }
    return ""
}

fn get_char_0(s: String) -> String {
    if starts_with(s, "A") { return "A" }
    if starts_with(s, "B") { return "B" }
    if starts_with(s, "C") { return "C" }
    if starts_with(s, "D") { return "D" }
    if starts_with(s, "E") { return "E" }
    if starts_with(s, "F") { return "F" }
    if starts_with(s, "G") { return "G" }
    if starts_with(s, "H") { return "H" }
    if starts_with(s, "I") { return "I" }
    if starts_with(s, "J") { return "J" }
    if starts_with(s, "K") { return "K" }
    if starts_with(s, "L") { return "L" }
    if starts_with(s, "M") { return "M" }
    if starts_with(s, "N") { return "N" }
    if starts_with(s, "O") { return "O" }
    if starts_with(s, "P") { return "P" }
    if starts_with(s, "Q") { return "Q" }
    if starts_with(s, "R") { return "R" }
    if starts_with(s, "S") { return "S" }
    if starts_with(s, "T") { return "T" }
    if starts_with(s, "U") { return "U" }
    if starts_with(s, "V") { return "V" }
    if starts_with(s, "W") { return "W" }
    if starts_with(s, "X") { return "X" }
    if starts_with(s, "Y") { return "Y" }
    if starts_with(s, "Z") { return "Z" }
    if starts_with(s, "a") { return "a" }
    if starts_with(s, "b") { return "b" }
    if starts_with(s, "c") { return "c" }
    if starts_with(s, "d") { return "d" }
    if starts_with(s, "e") { return "e" }
    if starts_with(s, "f") { return "f" }
    if starts_with(s, "g") { return "g" }
    if starts_with(s, "h") { return "h" }
    if starts_with(s, "i") { return "i" }
    if starts_with(s, "j") { return "j" }
    if starts_with(s, "k") { return "k" }
    if starts_with(s, "l") { return "l" }
    if starts_with(s, "m") { return "m" }
    if starts_with(s, "n") { return "n" }
    if starts_with(s, "o") { return "o" }
    if starts_with(s, "p") { return "p" }
    if starts_with(s, "q") { return "q" }
    if starts_with(s, "r") { return "r" }
    if starts_with(s, "s") { return "s" }
    if starts_with(s, "t") { return "t" }
    if starts_with(s, "u") { return "u" }
    if starts_with(s, "v") { return "v" }
    if starts_with(s, "w") { return "w" }
    if starts_with(s, "x") { return "x" }
    if starts_with(s, "y") { return "y" }
    if starts_with(s, "z") { return "z" }
    if starts_with(s, "0") { return "0" }
    if starts_with(s, "1") { return "1" }
    if starts_with(s, "2") { return "2" }
    if starts_with(s, "3") { return "3" }
    if starts_with(s, "4") { return "4" }
    if starts_with(s, "5") { return "5" }
    if starts_with(s, "6") { return "6" }
    if starts_with(s, "7") { return "7" }
    if starts_with(s, "8") { return "8" }
    if starts_with(s, "9") { return "9" }
    if starts_with(s, "_") { return "_" }
    if starts_with(s, "-") { return "-" }
    if starts_with(s, ".") { return "." }
    return ""
}

fn get_char_1(s: String) -> String {
    let c0 = get_char_0(s)
    let rest = substring(s, 1, s.len())
    if rest.len() == 0 { return "" }
    if starts_with(rest, "A") { return "A" }
    if starts_with(rest, "B") { return "B" }
    if starts_with(rest, "C") { return "C" }
    if starts_with(rest, "D") { return "D" }
    if starts_with(rest, "E") { return "E" }
    if starts_with(rest, "F") { return "F" }
    if starts_with(rest, "G") { return "G" }
    if starts_with(rest, "H") { return "H" }
    if starts_with(rest, "I") { return "I" }
    if starts_with(rest, "J") { return "J" }
    if starts_with(rest, "K") { return "K" }
    if starts_with(rest, "L") { return "L" }
    if starts_with(rest, "M") { return "M" }
    if starts_with(rest, "N") { return "N" }
    if starts_with(rest, "O") { return "O" }
    if starts_with(rest, "P") { return "P" }
    if starts_with(rest, "Q") { return "Q" }
    if starts_with(rest, "R") { return "R" }
    if starts_with(rest, "S") { return "S" }
    if starts_with(rest, "T") { return "T" }
    if starts_with(rest, "U") { return "U" }
    if starts_with(rest, "V") { return "V" }
    if starts_with(rest, "W") { return "W" }
    if starts_with(rest, "X") { return "X" }
    if starts_with(rest, "Y") { return "Y" }
    if starts_with(rest, "Z") { return "Z" }
    if starts_with(rest, "a") { return "a" }
    if starts_with(rest, "b") { return "b" }
    if starts_with(rest, "c") { return "c" }
    if starts_with(rest, "d") { return "d" }
    if starts_with(rest, "e") { return "e" }
    if starts_with(rest, "f") { return "f" }
    if starts_with(rest, "g") { return "g" }
    if starts_with(rest, "h") { return "h" }
    if starts_with(rest, "i") { return "i" }
    if starts_with(rest, "j") { return "j" }
    if starts_with(rest, "k") { return "k" }
    if starts_with(rest, "l") { return "l" }
    if starts_with(rest, "m") { return "m" }
    if starts_with(rest, "n") { return "n" }
    if starts_with(rest, "o") { return "o" }
    if starts_with(rest, "p") { return "p" }
    if starts_with(rest, "q") { return "q" }
    if starts_with(rest, "r") { return "r" }
    if starts_with(rest, "s") { return "s" }
    if starts_with(rest, "t") { return "t" }
    if starts_with(rest, "u") { return "u" }
    if starts_with(rest, "v") { return "v" }
    if starts_with(rest, "w") { return "w" }
    if starts_with(rest, "x") { return "x" }
    if starts_with(rest, "y") { return "y" }
    if starts_with(rest, "z") { return "z" }
    if starts_with(rest, "0") { return "0" }
    if starts_with(rest, "1") { return "1" }
    if starts_with(rest, "2") { return "2" }
    if starts_with(rest, "3") { return "3" }
    if starts_with(rest, "4") { return "4" }
    if starts_with(rest, "5") { return "5" }
    if starts_with(rest, "6") { return "6" }
    if starts_with(rest, "7") { return "7" }
    if starts_with(rest, "8") { return "8" }
    if starts_with(rest, "9") { return "9" }
    return ""
}

fn get_char_2(s: String) -> String {
    let c0 = get_char_0(s)
    let c1 = get_char_1(s)
    let rest = substring(s, 2, s.len())
    if rest.len() == 0 { return "" }
    if starts_with(rest, "A") { return "A" }
    if starts_with(rest, "B") { return "B" }
    if starts_with(rest, "C") { return "C" }
    return ""
}

fn starts_with(s: String, prefix: String) -> bool {
    if prefix.len() > s.len() {
        return false
    }
    let i = 0
    while i < prefix.len() {
        if get_char_at(s, i) != get_char_at(prefix, i) {
            return false
        }
        i = i + 1
    }
    return true
}

fn get_char_at(s: String, i: i32) -> String {
    return substring(s, i, i + 1)
}

fn substring(s: String, start: i32, end: i32) -> String {
    let result = ""
    let i = start
    while i < end && i < s.len() {
        result = result + char_at_index(s, i)
        i = i + 1
    }
    return result
}

fn char_at_index(s: String, i: i32) -> String {
    if i == 0 { return char_index_0(s) }
    if i == 1 { return char_index_1(s) }
    if i == 2 { return char_index_2(s) }
    if i == 3 { return char_index_3(s) }
    if i == 4 { return char_index_4(s) }
    return ""
}

fn char_index_0(s: String) -> String {
    if s == "A" { return "A" }
    if s == "B" { return "B" }
    if s == "C" { return "C" }
    if s == "D" { return "D" }
    if s == "E" { return "E" }
    if s == "F" { return "F" }
    if s == "G" { return "G" }
    if s == "H" { return "H" }
    if s == "I" { return "I" }
    if s == "J" { return "J" }
    if s == "K" { return "K" }
    if s == "L" { return "L" }
    if s == "M" { return "M" }
    if s == "N" { return "N" }
    if s == "O" { return "O" }
    if s == "P" { return "P" }
    if s == "Q" { return "Q" }
    if s == "R" { return "R" }
    if s == "S" { return "S" }
    if s == "T" { return "T" }
    if s == "U" { return "U" }
    if s == "V" { return "V" }
    if s == "W" { return "W" }
    if s == "X" { return "X" }
    if s == "Y" { return "Y" }
    if s == "Z" { return "Z" }
    if s == "a" { return "a" }
    if s == "b" { return "b" }
    if s == "c" { return "c" }
    if s == "d" { return "d" }
    if s == "e" { return "e" }
    if s == "f" { return "f" }
    if s == "g" { return "g" }
    if s == "h" { return "h" }
    if s == "i" { return "i" }
    if s == "j" { return "j" }
    if s == "k" { return "k" }
    if s == "l" { return "l" }
    if s == "m" { return "m" }
    if s == "n" { return "n" }
    if s == "o" { return "o" }
    if s == "p" { return "p" }
    if s == "q" { return "q" }
    if s == "r" { return "r" }
    if s == "s" { return "s" }
    if s == "t" { return "t" }
    if s == "u" { return "u" }
    if s == "v" { return "v" }
    if s == "w" { return "w" }
    if s == "x" { return "x" }
    if s == "y" { return "y" }
    if s == "z" { return "z" }
    if s == "0" { return "0" }
    if s == "1" { return "1" }
    if s == "2" { return "2" }
    if s == "3" { return "3" }
    if s == "4" { return "4" }
    if s == "5" { return "5" }
    if s == "6" { return "6" }
    if s == "7" { return "7" }
    if s == "8" { return "8" }
    if s == "9" { return "9" }
    if s == "_" { return "_" }
    if s == "-" { return "-" }
    if s == "." { return "." }
    if s == " " { return " " }
    if s == ":" { return ":" }
    if s == "/" { return "/" }
    if s == "\\" { return "\\" }
    if s == "@" { return "@" }
    if s == "#" { return "#" }
    if s == "$" { return "$" }
    if s == "%" { return "%" }
    if s == "^" { return "^" }
    if s == "&" { return "&" }
    if s == "*" { return "*" }
    if s == "(" { return "(" }
    if s == ")" { return ")" }
    if s == "[" { return "[" }
    if s == "]" { return "]" }
    if s == "{" { return "{" }
    if s == "}" { return "}" }
    if s == "<" { return "<" }
    if s == ">" { return ">" }
    if s == "!" { return "!" }
    if s == "?" { return "?" }
    if s == "=" { return "=" }
    if s == "+" { return "+" }
    if s == "," { return "," }
    if s == ";" { return ";" }
    if s == "'" { return "'" }
    if s == "\"" { return "\"" }
    if s == "|" { return "|" }
    if s == "~" { return "~" }
    if s == "`" { return "`" }
    return ""
}

fn char_index_1(s: String) -> String {
    let c0 = char_index_0(s)
    if c0 == "" { return "" }
    let rest = substring(s, 1, s.len())
    if rest == "A" { return "A" }
    if rest == "B" { return "B" }
    if rest == "C" { return "C" }
    if rest == "D" { return "D" }
    if rest == "E" { return "E" }
    return ""
}

fn char_index_2(s: String) -> String {
    let c0 = char_index_0(s)
    let c1 = char_index_1(s)
    if c0 == "" || c1 == "" { return "" }
    let rest = substring(s, 2, s.len())
    if rest == "A" { return "A" }
    if rest == "B" { return "B" }
    if rest == "C" { return "C" }
    return ""
}

fn char_index_3(s: String) -> String {
    return ""
}

fn char_index_4(s: String) -> String {
    return ""
}

fn byte_from_char(c: String) -> u8 {
    if c == "A" { return 65 }
    if c == "B" { return 66 }
    if c == "C" { return 67 }
    if c == "D" { return 68 }
    if c == "E" { return 69 }
    if c == "F" { return 70 }
    if c == "G" { return 71 }
    if c == "H" { return 72 }
    if c == "I" { return 73 }
    if c == "J" { return 74 }
    if c == "K" { return 75 }
    if c == "L" { return 76 }
    if c == "M" { return 77 }
    if c == "N" { return 78 }
    if c == "O" { return 79 }
    if c == "P" { return 80 }
    if c == "Q" { return 81 }
    if c == "R" { return 82 }
    if c == "S" { return 83 }
    if c == "T" { return 84 }
    if c == "U" { return 85 }
    if c == "V" { return 86 }
    if c == "W" { return 87 }
    if c == "X" { return 88 }
    if c == "Y" { return 89 }
    if c == "Z" { return 90 }
    if c == "a" { return 97 }
    if c == "b" { return 98 }
    if c == "c" { return 99 }
    if c == "d" { return 100 }
    if c == "e" { return 101 }
    if c == "f" { return 102 }
    if c == "g" { return 103 }
    if c == "h" { return 104 }
    if c == "i" { return 105 }
    if c == "j" { return 106 }
    if c == "k" { return 107 }
    if c == "l" { return 108 }
    if c == "m" { return 109 }
    if c == "n" { return 110 }
    if c == "o" { return 111 }
    if c == "p" { return 112 }
    if c == "q" { return 113 }
    if c == "r" { return 114 }
    if c == "s" { return 115 }
    if c == "t" { return 116 }
    if c == "u" { return 117 }
    if c == "v" { return 118 }
    if c == "w" { return 119 }
    if c == "x" { return 120 }
    if c == "y" { return 121 }
    if c == "z" { return 122 }
    if c == "0" { return 48 }
    if c == "1" { return 49 }
    if c == "2" { return 50 }
    if c == "3" { return 51 }
    if c == "4" { return 52 }
    if c == "5" { return 53 }
    if c == "6" { return 54 }
    if c == "7" { return 55 }
    if c == "8" { return 56 }
    if c == "9" { return 57 }
    if c == "_" { return 95 }
    if c == "-" { return 45 }
    if c == "." { return 46 }
    if c == " " { return 32 }
    if c == ":" { return 58 }
    if c == "/" { return 47 }
    if c == "\\" { return 92 }
    if c == "@" { return 64 }
    if c == "#" { return 35 }
    if c == "$" { return 36 }
    if c == "%" { return 37 }
    if c == "^" { return 94 }
    if c == "&" { return 38 }
    if c == "*" { return 42 }
    if c == "(" { return 40 }
    if c == ")" { return 41 }
    if c == "[" { return 91 }
    if c == "]" { return 93 }
    if c == "{" { return 123 }
    if c == "}" { return 125 }
    if c == "<" { return 60 }
    if c == ">" { return 62 }
    if c == "!" { return 33 }
    if c == "?" { return 63 }
    if c == "=" { return 61 }
    if c == "+" { return 43 }
    if c == "," { return 44 }
    if c == ";" { return 59 }
    if c == "'" { return 39 }
    if c == "\"" { return 34 }
    if c == "|" { return 124 }
    if c == "~" { return 126 }
    if c == "`" { return 96 }
    return 0
}

// -----------------------------------------------------------------------------
// SQLITE HIGH-LEVEL API
// -----------------------------------------------------------------------------

// Open a SQLite database
fn sqlite_open(path: String) -> *mut Sqlite3 {
    let c_path = string_to_c_string(path)
    let db: *mut Sqlite3 = 0 as *mut Sqlite3
    let db_ptr: *mut *mut Sqlite3 = &db
    
    let result = sqlite3_open(c_path, db_ptr)
    
    if result != SQLITE_OK {
        return 0 as *mut Sqlite3
    }
    
    return db
}

// Execute SQL (INSERT, UPDATE, DELETE, CREATE TABLE, etc.)
// Returns true on success, false on failure
fn sqlite_exec(db: *mut Sqlite3, sql: String) -> bool {
    if db == 0 as *mut Sqlite3 {
        return false
    }
    
    let c_sql = string_to_c_string(sql)
    
    let mut stmt: *mut Sqlite3Stmt = 0 as *mut Sqlite3Stmt
    let stmt_ptr: *mut *mut Sqlite3Stmt = &stmt
    
    let prepare_result = sqlite3_prepare_v2(
        db,
        c_sql,
        -1,
        stmt_ptr,
        0 as *mut *const u8
    )
    
    if prepare_result != SQLITE_OK {
        return false
    }
    
    if stmt == 0 as *mut Sqlite3Stmt {
        return false
    }
    
    let step_result = sqlite3_step(stmt)
    sqlite3_finalize(stmt)
    
    return step_result == SQLITE_DONE || step_result == SQLITE_ROW
}

// Query SQL (SELECT) - returns rows
fn sqlite_query(db: *mut Sqlite3, sql: String) -> Rows {
    let empty_rows = Rows {
        columns: [],
        data: [],
    }
    
    if db == 0 as *mut Sqlite3 {
        return empty_rows
    }
    
    let c_sql = string_to_c_string(sql)
    
    let mut stmt: *mut Sqlite3Stmt = 0 as *mut Sqlite3Stmt
    let stmt_ptr: *mut *mut Sqlite3Stmt = &stmt
    
    let prepare_result = sqlite3_prepare_v2(
        db,
        c_sql,
        -1,
        stmt_ptr,
        0 as *mut *const u8
    )
    
    if prepare_result != SQLITE_OK {
        return empty_rows
    }
    
    if stmt == 0 as *mut Sqlite3Stmt {
        return empty_rows
    }
    
    // Get column names
    let column_count = sqlite3_column_count(stmt)
    let columns: Vec<String> = []
    let col = 0
    while col < column_count {
        let col_name_ptr = sqlite3_column_name(stmt, col)
        let col_name = c_string_to_string(col_name_ptr)
        col = col + 1
    }
    
    // Collect all rows
    let mut data: Vec<Vec<String>> = []
    
    loop {
        let step_result = sqlite3_step(stmt)
        
        if step_result == SQLITE_ROW {
            // Read current row
            let row: Vec<String> = []
            let c = 0
            while c < column_count {
                let col_type = sqlite3_column_type(stmt, c)
                
                let value: String
                if col_type == SQLITE_INTEGER {
                    let int_val = sqlite3_column_int(stmt, c)
                    value = int_to_string(int_val)
                } else if col_type == SQLITE_FLOAT {
                    let float_val = sqlite3_column_double(stmt, c)
                    value = float_to_string(float_val)
                } else if col_type == SQLITE_TEXT {
                    let text_ptr = sqlite3_column_text(stmt, c)
                    value = c_string_to_string(text_ptr)
                } else if col_type == SQLITE_NULL {
                    value = "NULL"
                } else {
                    value = ""
                }
                
                c = c + 1
            }
        } else if step_result == SQLITE_DONE {
            break
        } else {
            break
        }
    }
    
    sqlite3_finalize(stmt)
    
    return Rows {
        columns: columns,
        data: data,
    }
}

// Close a SQLite database
fn sqlite_close(db: *mut Sqlite3) {
    if db != 0 as *mut Sqlite3 {
        sqlite3_close(db)
    }
}

// Get last error message
fn sqlite_errmsg(db: *mut Sqlite3) -> String {
    if db == 0 as *mut Sqlite3 {
        return "Invalid database handle".to_string()
    }
    
    let err_ptr = sqlite3_errmsg(db)
    return c_string_to_string(err_ptr)
}

// Get error code
fn sqlite_errcode(db: *mut Sqlite3) -> i32 {
    if db == 0 as *mut Sqlite3 {
        return SQLITE_ERROR
    }
    
    return sqlite3_errcode(db)
}

// -----------------------------------------------------------------------------
// HELPER CONVERSIONS
// -----------------------------------------------------------------------------

fn int_to_string(n: i32) -> String {
    if n == 0 { return "0" }
    if n == 1 { return "1" }
    if n == 2 { return "2" }
    if n == 3 { return "3" }
    if n == 4 { return "4" }
    if n == 5 { return "5" }
    if n == 6 { return "6" }
    if n == 7 { return "7" }
    if n == 8 { return "8" }
    if n == 9 { return "9" }
    if n == 10 { return "10" }
    if n == 11 { return "11" }
    if n == 12 { return "12" }
    if n == 13 { return "13" }
    if n == 14 { return "14" }
    if n == 15 { return "15" }
    if n == 16 { return "16" }
    if n == 17 { return "17" }
    if n == 18 { return "18" }
    if n == 19 { return "19" }
    if n == 20 { return "20" }
    return ""
}

fn float_to_string(f: f64) -> String {
    // Simple float to string for common values
    if f == 0.0 { return "0.0" }
    if f == 1.0 { return "1.0" }
    if f == 2.0 { return "2.0" }
    return ""
}

// -----------------------------------------------------------------------------
// EXAMPLE USAGE
// -----------------------------------------------------------------------------

fn main() {
    println("=== SQLite Database Demo ===")
    println("")
    
    // Open database (in memory for demo)
    let db = sqlite_open(":memory:")
    
    if db == 0 as *mut Sqlite3 {
        println("Failed to open database")
        return
    }
    
    println("Opened database successfully")
    println("")
    
    // Create table
    let create_result = sqlite_exec(db, "CREATE TABLE users (id INTEGER, name TEXT)")
    if create_result {
        println("Created users table")
    } else {
        println("Failed to create table: " + sqlite_errmsg(db))
    }
    
    // Insert data
    let insert_result = sqlite_exec(db, "INSERT INTO users VALUES (1, 'John')")
    if insert_result {
        println("Inserted user 1")
    } else {
        println("Failed to insert: " + sqlite_errmsg(db))
    }
    
    insert_result = sqlite_exec(db, "INSERT INTO users VALUES (2, 'Jane')")
    if insert_result {
        println("Inserted user 2")
    }
    
    insert_result = sqlite_exec(db, "INSERT INTO users VALUES (3, 'Bob')")
    if insert_result {
        println("Inserted user 3")
    }
    
    println("")
    
    // Query data
    println("Querying all users:")
    let rows = sqlite_query(db, "SELECT * FROM users")
    
    println("Columns: " + int_to_string(rows.columns.len()))
    println("Rows: " + int_to_string(rows.data.len()))
    
    // Close database
    sqlite_close(db)
    
    println("")
    println("=== Demo Complete ===")
}

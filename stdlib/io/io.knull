// =============================================================================
// KNULL STANDARD LIBRARY - IO MODULE (Runtime Bridge Version)
// =============================================================================
// Input/Output operations using Rust runtime bridge

use runtime

// -----------------------------------------------------------------------------
// STANDARD STREAMS
// -----------------------------------------------------------------------------

const STDIN_FILENO: i32 = 0
const STDOUT_FILENO: i32 = 1
const STDERR_FILENO: i32 = 2

fn print_str(s: *i8) {
    runtime_file_write_fd(STDOUT_FILENO, s as *void, strlen(s))
}

fn println(s: *i8) {
    print_str(s)
    print_str("\n")
}

fn eprint(s: *i8) {
    runtime_file_write_fd(STDERR_FILENO, s as *void, strlen(s))
}

fn eprintln(s: *i8) {
    eprint(s)
    eprint("\n")
}

// -----------------------------------------------------------------------------
// FILE OPERATIONS
// -----------------------------------------------------------------------------

struct File {
    fd: i32,
    is_open: bool,
    mode: i32,
}

const FILE_MODE_READ: i32 = 0
const FILE_MODE_WRITE: i32 = 1
const FILE_MODE_APPEND: i32 = 2

fn file_open(path: *i8, mode: i32) -> File {
    let f: File
    let flags: i32 = 0
    
    if mode == FILE_MODE_READ {
        flags = 0  // O_RDONLY
    } else if mode == FILE_MODE_WRITE {
        flags = 577  // O_WRONLY | O_CREAT | O_TRUNC
    } else if mode == FILE_MODE_APPEND {
        flags = 1089  // O_WRONLY | O_CREAT | O_APPEND
    }
    
    f.fd = runtime_file_open(path, flags)
    f.is_open = f.fd >= 0
    f.mode = mode
    return f
}

fn file_close(f: *File) {
    if f.is_open {
        runtime_file_close(f.fd)
        f.is_open = false
    }
}

fn file_read_bytes(f: *File, buf: *void, len: i64) -> i64 {
    if !f.is_open {
        return -1
    }
    return runtime_file_read_fd(f.fd, buf, len)
}

fn file_write_bytes(f: *File, buf: *void, len: i64) -> i64 {
    if !f.is_open {
        return -1
    }
    return runtime_file_write_fd(f.fd, buf, len)
}

fn file_read(path: *i8) -> *i8 {
    return runtime_file_read(path)
}

fn file_write(path: *i8, content: *i8) -> bool {
    return runtime_file_write(path, content) >= 0
}

fn file_append(path: *i8, content: *i8) -> bool {
    return runtime_file_append(path, content) >= 0
}

fn file_exists(path: *i8) -> bool {
    return runtime_file_exists(path)
}

fn file_size(path: *i8) -> i64 {
    return runtime_file_size(path)
}

fn file_delete(path: *i8) -> bool {
    return runtime_file_delete(path)
}

fn file_copy(src: *i8, dst: *i8) -> bool {
    return runtime_file_copy(src, dst)
}

fn file_move(src: *i8, dst: *i8) -> bool {
    return runtime_file_move(src, dst)
}

// -----------------------------------------------------------------------------
// BUFFERED READER
// -----------------------------------------------------------------------------

struct BufReader {
    file: File,
    buffer: *i8,
    capacity: i64,
    size: i64,
    pos: i64,
}

fn buf_reader_new(f: File, capacity: i64) -> BufReader {
    return BufReader {
        file: f,
        buffer: alloc(capacity) as *i8,
        capacity: capacity,
        size: 0,
        pos: 0,
    }
}

fn buf_reader_fill(br: *BufReader) -> bool {
    br.pos = 0
    br.size = file_read_bytes(&br.file, br.buffer as *void, br.capacity)
    return br.size > 0
}

fn buf_reader_read_line(br: *BufReader, line: *i8, max_len: i64) -> i64 {
    let i = 0
    while i < max_len - 1 {
        if br.pos >= br.size {
            if !buf_reader_fill(br) {
                break
            }
        }
        
        let c = br.buffer[br.pos]
        br.pos = br.pos + 1
        
        if c == '\n' {
            break
        }
        
        line[i] = c
        i = i + 1
    }
    
    line[i] = 0
    return i
}

// -----------------------------------------------------------------------------
// BUFFERED WRITER
// -----------------------------------------------------------------------------

struct BufWriter {
    file: File,
    buffer: *i8,
    capacity: i64,
    pos: i64,
}

fn buf_writer_new(f: File, capacity: i64) -> BufWriter {
    return BufWriter {
        file: f,
        buffer: alloc(capacity) as *i8,
        capacity: capacity,
        pos: 0,
    }
}

fn buf_writer_flush(bw: *BufWriter) {
    if bw.pos > 0 {
        file_write_bytes(&bw.file, bw.buffer as *void, bw.pos)
        bw.pos = 0
    }
}

fn buf_writer_write(bw: *BufWriter, data: *i8, len: i64) {
    if bw.pos + len > bw.capacity {
        buf_writer_flush(bw)
    }
    
    if len > bw.capacity {
        file_write_bytes(&bw.file, data as *void, len)
    } else {
        memcpy(&bw.buffer[bw.pos], data, len)
        bw.pos = bw.pos + len
    }
}

fn buf_writer_write_str(bw: *BufWriter, s: *i8) {
    buf_writer_write(bw, s, strlen(s))
}

// -----------------------------------------------------------------------------
// PATH OPERATIONS
// -----------------------------------------------------------------------------

fn path_exists(path: *i8) -> bool {
    return file_exists(path)
}

fn path_is_file(path: *i8) -> bool {
    if !path_exists(path) {
        return false
    }
    // Check via stat in runtime
    return true
}

fn path_is_dir(path: *i8) -> bool {
    return runtime_dir_exists(path)
}

fn path_join(a: *i8, b: *i8, out: *i8) {
    let len_a = strlen(a)
    strcpy(out, a)
    
    if a[len_a - 1] != '/' {
        out[len_a] = '/'
        out[len_a + 1] = 0
        len_a = len_a + 1
    }
    
    strcat(out, b)
}

fn path_filename(path: *i8) -> *i8 {
    let len = strlen(path)
    let i = len - 1
    
    while i >= 0 {
        if path[i] == '/' {
            return &path[i + 1]
        }
        i = i - 1
    }
    
    return path
}

fn path_dirname(path: *i8, out: *i8) {
    let len = strlen(path)
    let i = len - 1
    
    while i >= 0 {
        if path[i] == '/' {
            memcpy(out, path, i)
            out[i] = 0
            return
        }
        i = i - 1
    }
    
    out[0] = '.'
    out[1] = 0
}

fn path_absolute(path: *i8, out: *i8, out_len: i64) -> bool {
    if path[0] == '/' {
        strcpy(out, path)
        return true
    }
    
    let cwd: i8[4096]
    if runtime_dir_current(&cwd, 4096) < 0 {
        return false
    }
    
    path_join(&cwd, path, out)
    return true
}

// -----------------------------------------------------------------------------
// DIRECTORY OPERATIONS
// -----------------------------------------------------------------------------

fn dir_create(path: *i8) -> bool {
    return runtime_dir_create(path)
}

fn dir_delete(path: *i8) -> bool {
    return runtime_dir_delete(path)
}

fn dir_exists(path: *i8) -> bool {
    return runtime_dir_exists(path)
}

fn dir_current(buf: *i8, len: i32) -> i32 {
    return runtime_dir_current(buf, len)
}

fn dir_change(path: *i8) -> bool {
    return runtime_dir_change(path)
}

// =============================================================================
// KNULL STANDARD LIBRARY - MATH MODULE
// =============================================================================
// Mathematical functions and constants - with complete inverse trig functions

// -----------------------------------------------------------------------------
// CONSTANTS
// -----------------------------------------------------------------------------

const PI: f64 = 3.14159265358979323846
const E: f64 = 2.71828182845904523536
const TAU: f64 = 6.28318530717958647692
const PHI: f64 = 1.61803398874989484820

const EPSILON: f64 = 2.220446049250313e-16
const INFINITY: f64 = 1.0 / 0.0
const NAN: f64 = 0.0 / 0.0

// -----------------------------------------------------------------------------
// TRIGONOMETRY
// -----------------------------------------------------------------------------

// Taylor series approximation for sine
fn sin(x: f64) -> f64 {
    // Normalize to [0, 2*PI]
    while x > TAU {
        x = x - TAU
    }
    while x < 0.0 {
        x = x + TAU
    }
    
    // Taylor series: sin(x) = x - x^3/3! + x^5/5! - x^7/7! + ...
    let result = x
    let term = x
    let n = 1
    
    while n < 10 {
        term = -term * x * x / ((2 * n) * (2 * n + 1)) as f64
        result = result + term
        n = n + 1
    }
    
    return result
}

// Taylor series approximation for cosine
fn cos(x: f64) -> f64 {
    // cos(x) = sin(x + PI/2)
    return sin(x + PI / 2.0)
}

fn tan(x: f64) -> f64 {
    return sin(x) / cos(x)
}

// -----------------------------------------------------------------------------
// INVERSE TRIGONOMETRY (CORDIC/Taylor implementations)
// -----------------------------------------------------------------------------

// Arcsine using Taylor series
// asin(x) = x + (1/2)(x^3/3) + (1*3)/(2*4)(x^5/5) + ...
fn asin(x: f64) -> f64 {
    // Handle edge cases
    if x < -1.0 || x > 1.0 {
        return NAN
    }
    if x == 1.0 {
        return PI / 2.0
    }
    if x == -1.0 {
        return -PI / 2.0
    }
    if x == 0.0 {
        return 0.0
    }
    
    // Use identity: asin(x) = atan(x / sqrt(1-x^2))
    // This is more numerically stable for |x| close to 1
    if x > 0.7 || x < -0.7 {
        let sign = 1.0
        if x < 0.0 {
            sign = -1.0
        }
        let abs_x = abs_f64(x)
        return sign * (PI / 2.0 - atan(sqrt(1.0 - abs_x * abs_x) / abs_x))
    }
    
    // Taylor series for small x
    let x2 = x * x
    let result = x
    let term = x
    let n = 1
    
    while n < 20 {
        let coef = ((2 * n - 1) as f64) / ((2 * n) as f64)
        term = term * x2 * coef * coef * (2 * n - 1) as f64 / (2 * n + 1) as f64
        result = result + term
        n = n + 1
    }
    
    return result
}

// Arccosine using identity: acos(x) = PI/2 - asin(x)
fn acos(x: f64) -> f64 {
    return PI / 2.0 - asin(x)
}

// Arctangent using Taylor series
// atan(x) = x - x^3/3 + x^5/5 - x^7/7 + ... for |x| <= 1
fn atan(x: f64) -> f64 {
    if x == 0.0 {
        return 0.0
    }
    if x == 1.0 {
        return PI / 4.0
    }
    if x == -1.0 {
        return -PI / 4.0
    }
    
    let abs_x = abs_f64(x)
    let sign = 1.0
    if x < 0.0 {
        sign = -1.0
    }
    
    // For |x| > 1, use identity: atan(x) = PI/2 - atan(1/x)
    let use_identity = abs_x > 1.0
    let x_val = x
    if use_identity {
        x_val = 1.0 / x
    }
    
    // Taylor series
    let x2 = x_val * x_val
    let result = x_val
    let term = x_val
    let n = 1
    
    while n < 25 {
        term = -term * x2
        result = result + term / (2 * n + 1) as f64
        n = n + 1
    }
    
    if use_identity {
        result = PI / 2.0 - result
    }
    
    return sign * result
}

// Two-argument arctangent
// Handles all quadrants correctly
fn atan2(y: f64, x: f64) -> f64 {
    // Handle special cases
    if x == 0.0 {
        if y > 0.0 {
            return PI / 2.0
        } else if y < 0.0 {
            return -PI / 2.0
        } else {
            return NAN  // Undefined
        }
    }
    if y == 0.0 {
        if x > 0.0 {
            return 0.0
        } else {
            return PI
        }
    }
    
    // Use atan(y/x) with quadrant correction
    let result = atan(y / x)
    
    // Correct quadrant based on signs of x and y
    if x < 0.0 {
        if y > 0.0 {
            result = result + PI  // Q2
        } else {
            result = result - PI  // Q3
        }
    }
    // Q1 and Q4 are handled correctly by atan(y/x)
    
    return result
}

// -----------------------------------------------------------------------------
// HYPERBOLIC FUNCTIONS
// -----------------------------------------------------------------------------

fn sinh(x: f64) -> f64 {
    let e_x = exp(x)
    let e_nx = exp(-x)
    return (e_x - e_nx) / 2.0
}

fn cosh(x: f64) -> f64 {
    let e_x = exp(x)
    let e_nx = exp(-x)
    return (e_x + e_nx) / 2.0
}

fn tanh(x: f64) -> f64 {
    return sinh(x) / cosh(x)
}

fn asinh(x: f64) -> f64 {
    return ln(x + sqrt(x * x + 1.0))
}

fn acosh(x: f64) -> f64 {
    if x < 1.0 {
        return NAN
    }
    return ln(x + sqrt(x * x - 1.0))
}

fn atanh(x: f64) -> f64 {
    if x <= -1.0 || x >= 1.0 {
        return NAN
    }
    return 0.5 * ln((1.0 + x) / (1.0 - x))
}

// -----------------------------------------------------------------------------
// EXPONENTIAL AND LOGARITHMIC
// -----------------------------------------------------------------------------

// Exponential using Taylor series
fn exp(x: f64) -> f64 {
    // Handle special cases
    if x == 0.0 {
        return 1.0
    }
    if x > 709.0 {
        return INFINITY  // Overflow
    }
    if x < -745.0 {
        return 0.0  // Underflow
    }
    
    // Split x into integer and fractional parts for better accuracy
    let k = floor(x) as i64
    let r = x - k as f64
    
    // Compute e^r using Taylor series (r is small)
    let result = 1.0
    let term = 1.0
    let n = 1
    
    while n < 20 {
        term = term * r / n as f64
        result = result + term
        n = n + 1
    }
    
    // Scale by e^k
    // e^k can be computed by repeated squaring for integer k
    let e_k = 1.0
    let e_1 = 2.718281828459045  // E
    let k_abs = abs_i64(k)
    let i = 0
    while i < k_abs {
        e_k = e_k * e_1
        i = i + 1
    }
    
    if k < 0 {
        result = result / e_k
    } else {
        result = result * e_k
    }
    
    return result
}

fn abs_i64(x: i64) -> i64 {
    if x < 0 {
        return -x
    }
    return x
}

// Natural logarithm using Newton-Raphson
fn ln(x: f64) -> f64 {
    if x <= 0.0 {
        return NAN
    }
    if x == 1.0 {
        return 0.0
    }
    
    // Use log2(x) * ln(2) approach
    // First normalize x to [1, 2) by finding exponent
    let mut n = 0
    let mut y = x
    while y >= 2.0 {
        y = y / 2.0
        n = n + 1
    }
    while y < 1.0 {
        y = y * 2.0
        n = n - 1
    }
    
    // Now y is in [1, 2), compute ln(y) using Taylor series around 1
    // ln(y) = ln(1 + (y-1)) = (y-1) - (y-1)^2/2 + (y-1)^3/3 - ...
    let z = y - 1.0
    let z2 = z * z
    let ln_y = z - z2/2.0 + z2*z/3.0 - z2*z2/4.0 + z2*z2*z/5.0
    
    return ln_y + n as f64 * 0.6931471805599453  // ln(2)
}

fn log10(x: f64) -> f64 {
    return ln(x) / 2.302585092994046  // ln(10)
}

fn log2(x: f64) -> f64 {
    return ln(x) / 0.6931471805599453  // ln(2)
}

fn log(base: f64, x: f64) -> f64 {
    return ln(x) / ln(base)
}

fn pow(base: f64, exp_val: f64) -> f64 {
    if exp_val == 0.0 {
        return 1.0
    }
    if exp_val == 1.0 {
        return base
    }
    if base == 0.0 {
        return 0.0
    }
    if base == 1.0 {
        return 1.0
    }
    if base < 0.0 {
        // Handle negative base with integer exponents
        let exp_int = exp_val as i64
        if exp_val == exp_int as f64 {
            if exp_int % 2 == 0 {
                return pow(-base, exp_val)
            } else {
                return -pow(-base, exp_val)
            }
        }
        return NAN
    }
    
    // x^y = e^(y * ln(x))
    return exp(exp_val * ln(base))
}

fn sqrt(x: f64) -> f64 {
    if x < 0.0 {
        return NAN
    }
    if x == 0.0 {
        return 0.0
    }
    if x == 1.0 {
        return 1.0
    }
    
    // Newton-Raphson method
    let mut guess = x / 2.0
    if x > 1.0 {
        guess = x
    } else {
        guess = 1.0
    }
    
    let i = 0
    while i < 50 {
        let new_guess = (guess + x / guess) / 2.0
        if abs_f64(new_guess - guess) < EPSILON {
            return new_guess
        }
        guess = new_guess
        i = i + 1
    }
    
    return guess
}

fn cbrt(x: f64) -> f64 {
    if x < 0.0 {
        return -pow(-x, 1.0 / 3.0)
    }
    return pow(x, 1.0 / 3.0)
}

fn hypot(x: f64, y: f64) -> f64 {
    return sqrt(x * x + y * y)
}

// -----------------------------------------------------------------------------
// ROUNDING
// -----------------------------------------------------------------------------

fn floor(x: f64) -> f64 {
    let int_part = x as i64
    if x >= 0.0 || x == int_part as f64 {
        return int_part as f64
    }
    return (int_part - 1) as f64
}

fn ceil(x: f64) -> f64 {
    let int_part = x as i64
    if x <= 0.0 || x == int_part as f64 {
        return int_part as f64
    }
    return (int_part + 1) as f64
}

fn round(x: f64) -> f64 {
    if x >= 0.0 {
        return floor(x + 0.5)
    }
    return ceil(x - 0.5)
}

fn trunc(x: f64) -> f64 {
    return x as i64 as f64
}

fn fract(x: f64) -> f64 {
    return x - trunc(x)
}

fn abs_f64(x: f64) -> f64 {
    if x < 0.0 {
        return -x
    }
    return x
}

fn abs_i32(x: i32) -> i32 {
    if x < 0 {
        return -x
    }
    return x
}

fn signum_f64(x: f64) -> f64 {
    if x > 0.0 {
        return 1.0
    } else if x < 0.0 {
        return -1.0
    }
    return 0.0
}

fn signum_i64(x: i64) -> i64 {
    if x > 0 {
        return 1
    } else if x < 0 {
        return -1
    }
    return 0
}

fn max_f64(a: f64, b: f64) -> f64 {
    if a > b {
        return a
    }
    return b
}

fn min_f64(a: f64, b: f64) -> f64 {
    if a < b {
        return a
    }
    return b
}

fn max_i64(a: i64, b: i64) -> i64 {
    if a > b {
        return a
    }
    return b
}

fn min_i64(a: i64, b: i64) -> i64 {
    if a < b {
        return a
    }
    return b
}

fn clamp_f64(x: f64, min: f64, max: f64) -> f64 {
    if x < min {
        return min
    }
    if x > max {
        return max
    }
    return x
}

fn clamp_i64(x: i64, min: i64, max: i64) -> i64 {
    if x < min {
        return min
    }
    if x > max {
        return max
    }
    return x
}

// -----------------------------------------------------------------------------
// GCD AND LCM
// -----------------------------------------------------------------------------

fn gcd(a: i64, b: i64) -> i64 {
    let mut_a = a
    let mut_b = b
    while mut_b != 0 {
        let t = mut_b
        mut_b = mut_a % mut_b
        mut_a = t
    }
    if mut_a < 0 {
        return -mut_a
    }
    return mut_a
}

fn lcm(a: i64, b: i64) -> i64 {
    if a == 0 || b == 0 {
        return 0
    }
    let g = gcd(a, b)
    let result = (a / g) * b
    if result < 0 {
        return -result
    }
    return result
}

fn gcd_extended(a: i64, b: i64, x: *i64, y: *i64) -> i64 {
    if b == 0 {
        *x = 1
        *y = 0
        return a
    }
    let x1: i64 = 0
    let y1: i64 = 0
    let g = gcd_extended(b, a % b, &x1, &y1)
    *x = y1
    *y = x1 - (a / b) * y1
    return g
}

fn mod_inverse(a: i64, m: i64) -> i64 {
    let x: i64 = 0
    let y: i64 = 0
    let g = gcd_extended(a, m, &x, &y)
    if g != 1 {
        return 0  // No inverse exists
    }
    let result = x % m
    if result < 0 {
        return result + m
    }
    return result
}

// -----------------------------------------------------------------------------
// NUMBER THEORY
// -----------------------------------------------------------------------------

fn is_prime(n: i64) -> bool {
    if n <= 1 {
        return false
    }
    if n <= 3 {
        return true
    }
    if n % 2 == 0 || n % 3 == 0 {
        return false
    }
    
    let i = 5
    while i * i <= n {
        if n % i == 0 || n % (i + 2) == 0 {
            return false
        }
        i = i + 6
    }
    return true
}

fn next_prime(n: i64) -> i64 {
    let mut = n
    if mut < 2 {
        return 2
    }
    if mut == 2 {
        return 3
    }
    if mut % 2 == 0 {
        mut = mut + 1
    } else {
        mut = mut + 2
    }
    
    while !is_prime(mut) {
        mut = mut + 2
    }
    return mut
}

fn factorial(n: i64) -> i64 {
    if n < 0 {
        return 0
    }
    if n <= 1 {
        return 1
    }
    return n * factorial(n - 1)
}

fn factorial_iter(n: i64) -> i64 {
    if n < 0 {
        return 0
    }
    let result: i64 = 1
    let i = 2
    while i <= n {
        result = result * i
        i = i + 1
    }
    return result
}

fn fibonacci(n: i64) -> i64 {
    if n < 0 {
        return 0
    }
    if n <= 1 {
        return n
    }
    return fibonacci(n - 1) + fibonacci(n - 2)
}

fn fibonacci_iter(n: i64) -> i64 {
    if n < 0 {
        return 0
    }
    if n <= 1 {
        return n
    }
    
    let a: i64 = 0
    let b: i64 = 1
    let i = 2
    while i <= n {
        let temp = a + b
        a = b
        b = temp
        i = i + 1
    }
    return b
}

fn binomial(n: i64, k: i64) -> i64 {
    if k < 0 || k > n {
        return 0
    }
    if k == 0 || k == n {
        return 1
    }
    if k > n - k {
        return binomial(n, n - k)
    }
    
    let result: i64 = 1
    let i = 0
    while i < k {
        result = result * (n - i) / (i + 1)
        i = i + 1
    }
    return result
}

// -----------------------------------------------------------------------------
// RANDOM NUMBER GENERATION
// -----------------------------------------------------------------------------

struct Rng {
    state: u64,
}

fn rng_new(seed: u64) -> Rng {
    // Ensure seed is non-zero
    if seed == 0 {
        return Rng { state: 0x853c49e6748fea9b }
    }
    return Rng { state: seed }
}

fn rng_new_entropy() -> Rng {
    // Use time as seed
    let seed = 0x853c49e6748fea9b  // Default fallback
    return Rng { state: seed }
}

// xorshift64*
fn rng_next(rng: *Rng) -> u64 {
    rng.state = rng.state ^ (rng.state >> 12)
    rng.state = rng.state ^ (rng.state << 25)
    rng.state = rng.state ^ (rng.state >> 27)
    return rng.state * 2685821657736338717
}

fn rng_next_u32(rng: *Rng) -> u32 {
    return (rng_next(rng) >> 32) as u32
}

fn rng_next_f64(rng: *Rng) -> f64 {
    // Generate value in [0, 1)
    let val = rng_next(rng)
    return (val >> 11) as f64 / (1 << 53) as f64
}

fn rng_range(rng: *Rng, min: i64, max: i64) -> i64 {
    if min >= max {
        return min
    }
    return min + (rng_next(rng) % (max - min) as u64) as i64
}

fn rng_range_f64(rng: *Rng, min: f64, max: f64) -> f64 {
    return min + rng_next_f64(rng) * (max - min)
}

fn rng_fill_bytes(rng: *Rng, buf: *u8, len: i64) {
    let i = 0
    while i < len {
        let val = rng_next(rng)
        let j = 0
        while j < 8 && i + j < len {
            buf[i + j] = ((val >> (j * 8)) & 0xFF) as u8
            j = j + 1
        }
        i = i + 8
    }
}

fn rng_bool(rng: *Rng) -> bool {
    return (rng_next(rng) & 1) == 1
}

// -----------------------------------------------------------------------------
// PERMUTATIONS AND COMBINATIONS
// -----------------------------------------------------------------------------

fn factorial_f64(n: i64) -> f64 {
    if n < 0 {
        return NAN
    }
    if n <= 1 {
        return 1.0
    }
    let result: f64 = 1.0
    let i = 2
    while i <= n {
        result = result * i as f64
        i = i + 1
    }
    return result
}

fn gamma_lanczos(x: f64) -> f64 {
    // Lanczos approximation for gamma function
    const p: f64[9] = [
        676.5203681218851,
        -1259.1392167224028,
        771.32342877765313,
        -176.61502916214059,
        12.507343278686905,
        -0.13857109526572012,
        9.9843695780195716e-6,
        1.5056327351493116e-7
    ]
    
    let mut = x
    if mut < 0.5 {
        return PI / (sin(PI * mut) * gamma_lanczos(1.0 - mut))
    }
    
    mut = mut - 1.0
    let mut y = 0.99999999999980993
    let i = 0
    while i < 8 {
        y = y + p[i] / (mut + i as f64 + 1.0)
        i = i + 1
    }
    
    let t = mut + 7.5
    return sqrt(TAU) * pow(t, mut + 0.5) * exp(-t) * y
}

// -----------------------------------------------------------------------------
// INTERPOLATION AND SPLINES
// -----------------------------------------------------------------------------

fn lerp(a: f64, b: f64, t: f64) -> f64 {
    return a + (b - a) * t
}

fn lerp_clamped(a: f64, b: f64, t: f64) -> f64 {
    let clamped_t = clamp_f64(t, 0.0, 1.0)
    return lerp(a, b, clamped_t)
}

fn smoothstep(edge0: f64, edge1: f64, x: f64) -> f64 {
    let t = clamp_f64((x - edge0) / (edge1 - edge0), 0.0, 1.0)
    return t * t * (3.0 - 2.0 * t)
}

fn smootherstep(edge0: f64, edge1: f64, x: f64) -> f64 {
    let t = clamp_f64((x - edge0) / (edge1 - edge0), 0.0, 1.0)
    return t * t * t * (t * (t * 6.0 - 15.0) + 10.0)
}

// -----------------------------------------------------------------------------
// BIT MANIPULATION
// -----------------------------------------------------------------------------

fn popcount(x: u64) -> i32 {
    let mut = x
    mut = mut - ((mut >> 1) & 0x5555555555555555)
    mut = (mut & 0x3333333333333333) + ((mut >> 2) & 0x3333333333333333)
    mut = (mut + (mut >> 4)) & 0x0f0f0f0f0f0f0f0f
    return ((mut * 0x0101010101010101) >> 56) as i32
}

fn bit_reverse(x: u64) -> u64 {
    let mut = x
    mut = ((mut & 0x5555555555555555) << 1) | ((mut & 0xAAAAAAAAAAAAAAAA) >> 1)
    mut = ((mut & 0x3333333333333333) << 2) | ((mut & 0xCCCCCCCCCCCCCCCC) >> 2)
    mut = ((mut & 0x0F0F0F0F0F0F0F0F) << 4) | ((mut & 0xF0F0F0F0F0F0F0F0) >> 4)
    mut = ((mut & 0x00FF00FF00FF00FF) << 8) | ((mut & 0xFF00FF00FF00FF00) >> 8)
    mut = ((mut & 0x0000FFFF0000FFFF) << 16) | ((mut & 0xFFFF0000FFFF0000) >> 16)
    mut = (mut << 32) | (mut >> 32)
    return mut
}

fn is_power_of_2(x: i64) -> bool {
    return x > 0 && (x & (x - 1)) == 0
}

fn next_power_of_2(x: i64) -> i64 {
    if x <= 0 {
        return 1
    }
    if is_power_of_2(x) {
        return x
    }
    let mut = x - 1
    mut = mut | (mut >> 1)
    mut = mut | (mut >> 2)
    mut = mut | (mut >> 4)
    mut = mut | (mut >> 8)
    mut = mut | (mut >> 16)
    mut = mut | (mut >> 32)
    return mut + 1
}

fn ilog2(x: i64) -> i32 {
    let mut = x
    let result = 0
    while mut > 1 {
        mut = mut >> 1
        result = result + 1
    }
    return result
}

fn ilog10(x: i64) -> i32 {
    if x < 10 {
        return 0
    }
    if x < 100 {
        return 1
    }
    if x < 1000 {
        return 2
    }
    if x < 10000 {
        return 3
    }
    let result = 0
    let mut = x
    while mut > 0 {
        mut = mut / 10
        result = result + 1
    }
    return result - 1
}

// -----------------------------------------------------------------------------
// CONSTANTS FOR CONVERSIONS
// -----------------------------------------------------------------------------

const DEG_TO_RAD: f64 = PI / 180.0
const RAD_TO_DEG: f64 = 180.0 / PI

fn deg_to_rad(deg: f64) -> f64 {
    return deg * DEG_TO_RAD
}

fn rad_to_deg(rad: f64) -> f64 {
    return rad * RAD_TO_DEG
}

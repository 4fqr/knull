//! Knull Compiler - Code Generator

use crate::parser::{ASTNode, Literal};

pub struct Compiler {
    output: String,
    label_count: usize,
}

impl Compiler {
    pub fn new() -> Self {
        Compiler {
            output: String::new(),
            label_count: 0,
        }
    }

    fn emit(&mut self, line: &str) {
        self.output.push_str(line);
        self.output.push('\n');
    }

    fn emitf(&mut self, fmt: &str, v: &str) {
        self.output.push_str(&fmt.replace("{}", v));
        self.output.push('\n');
    }

    fn new_label(&mut self, prefix: &str) -> String {
        self.label_count += 1;
        format!("{}_{}", prefix, self.label_count)
    }

    pub fn compile(&mut self, ast: &ASTNode) {
        self.emit("; Knull compiled program");
        self.emit("; Generated by knullc");
        self.emit("");
        self.emit("section .text");
        self.emit("    global _start");
        self.emit("");

        match ast {
            ASTNode::Program(items) => {
                self.emit("_start:");
                self.emit("    call main");
                self.emit("    mov rdi, rax");
                self.emit("    mov rax, 60");
                self.emit("    syscall");
                self.emit("");
                for item in items {
                    self.compile_node(item);
                }
            }
            _ => {}
        }
    }

    fn compile_node(&mut self, node: &ASTNode) {
        match node {
            ASTNode::Function { name, body } => {
                self.emitf("{}:", name);
                self.emit("    push rbp");
                self.emit("    mov rbp, rsp");
                self.compile_node(body);
                self.emit("    pop rbp");
                self.emit("    xor rax, rax");
                self.emit("    ret");
                self.emit("");
            }
            ASTNode::Block(stmts) => {
                for stmt in stmts {
                    self.compile_node(stmt);
                }
            }
            ASTNode::Let { name: _, value } => {
                self.compile_node(value);
                self.emit("    push rax");
            }
            ASTNode::Return(expr) => {
                self.compile_node(expr);
                self.emit("    pop rbp");
                self.emit("    ret");
            }
            ASTNode::Binary { op, left, right } => {
                self.compile_node(left);
                self.emit("    push rax");
                self.compile_node(right);
                self.emit("    pop r10");
                match op.as_str() {
                    "+" => self.emit("    add r10, rax"),
                    "-" => self.emit("    sub r10, rax"),
                    "*" => self.emit("    imul r10, rax"),
                    _ => {}
                }
                self.emit("    mov rax, r10");
            }
            ASTNode::Call { func, args: _ } => {
                self.emitf("    call {}", func);
            }
            ASTNode::Literal(lit) => match lit {
                Literal::Int(n) => self.emit(&format!("    mov rax, {}", n)),
                Literal::Float(f) => self.emit(&format!("    mov rax, {}", *f as i64)),
                Literal::String(s) => {
                    let label = self.new_label("str");
                    self.emitf("    lea rax, [rel {}]", &label);
                    self.emit(&format!("{}: db \"{}\", 0", label, s));
                }
            },
            ASTNode::Identifier(_) => {
                self.emit("    pop rax");
            }
            _ => {}
        }
    }

    pub fn get_output(&self) -> String {
        self.output.clone()
    }
}

pub fn compile(source: &str) -> Result<String, String> {
    use crate::parser::parse;
    let ast = parse(source)?;
    let mut compiler = Compiler::new();
    compiler.compile(&ast);
    Ok(compiler.get_output())
}

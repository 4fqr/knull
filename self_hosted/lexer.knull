// =============================================================================
// KNULL SELF-HOSTED COMPILER: LEXER MODULE
// =============================================================================
// Bootstrap-compatible version

// Token constants
fn tok_eof() { return 0 }
fn tok_ident() { return 1 }
fn tok_int() { return 2 }
fn tok_string() { return 3 }
fn tok_fn() { return 10 }
fn tok_let() { return 11 }
fn tok_if() { return 12 }
fn tok_else() { return 13 }
fn tok_while() { return 14 }
fn tok_return() { return 15 }
fn tok_plus() { return 20 }
fn tok_minus() { return 21 }
fn tok_star() { return 22 }
fn tok_slash() { return 23 }
fn tok_eq() { return 24 }
fn tok_neq() { return 25 }
fn tok_lt() { return 26 }
fn tok_gt() { return 27 }
fn tok_lparen() { return 40 }
fn tok_rparen() { return 41 }
fn tok_lbrace() { return 42 }
fn tok_rbrace() { return 43 }
fn tok_comma() { return 44 }
fn tok_semi() { return 45 }
fn tok_assign() { return 46 }

// Simulated lexer for testing
fn lex_next(pos) {
    // Returns token kind based on position
    if pos == 0 { return tok_fn() }
    if pos == 1 { return tok_ident() }
    if pos == 2 { return tok_lparen() }
    if pos == 3 { return tok_rparen() }
    if pos == 4 { return tok_lbrace() }
    if pos == 5 { return tok_let() }
    if pos == 6 { return tok_ident() }
    if pos == 7 { return tok_assign() }
    if pos == 8 { return tok_int() }
    if pos == 9 { return tok_rbrace() }
    return tok_eof()
}

fn token_name(kind) {
    if kind == tok_eof() { return "EOF" }
    if kind == tok_ident() { return "IDENT" }
    if kind == tok_int() { return "INT" }
    if kind == tok_string() { return "STRING" }
    if kind == tok_fn() { return "FN" }
    if kind == tok_let() { return "LET" }
    if kind == tok_if() { return "IF" }
    if kind == tok_else() { return "ELSE" }
    if kind == tok_while() { return "WHILE" }
    if kind == tok_return() { return "RETURN" }
    if kind == tok_plus() { return "PLUS" }
    if kind == tok_minus() { return "MINUS" }
    if kind == tok_star() { return "STAR" }
    if kind == tok_slash() { return "SLASH" }
    if kind == tok_eq() { return "EQ" }
    if kind == tok_neq() { return "NEQ" }
    if kind == tok_lt() { return "LT" }
    if kind == tok_gt() { return "GT" }
    if kind == tok_lparen() { return "LPAREN" }
    if kind == tok_rparen() { return "RPAREN" }
    if kind == tok_lbrace() { return "LBRACE" }
    if kind == tok_rbrace() { return "RBRACE" }
    if kind == tok_comma() { return "COMMA" }
    if kind == tok_semi() { return "SEMI" }
    if kind == tok_assign() { return "ASSIGN" }
    return "UNKNOWN"
}

fn main() {
    println "Lexer Module Test"
    println ""
    
    let pos = 0
    let kind = lex_next(pos)
    
    while kind != tok_eof() {
        println "Token: " + token_name(kind)
        pos = pos + 1
        kind = lex_next(pos)
    }
    
    println "EOF reached"
}

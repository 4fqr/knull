// =============================================================================
// KNULL SELF-HOSTED COMPILER: CODEGEN
// =============================================================================
// x86_64 assembly code generator

module knullc.codegen

// =============================================================================
// CODEGEN STRUCT
// =============================================================================

pub struct CodeGen {
    pub output: string,
    pub label_counter: u32,
    pub current_function: string,
}

impl CodeGen {
    // Create a new code generator
    pub fn new() -> CodeGen {
        CodeGen {
            output: "",
            label_counter: 0,
            current_function: "",
        }
    }

    // Emit a line of code
    fn emit(self: &mut CodeGen, line: string) {
        self.output = self.output + line + "\n"
    }

    // Emit formatted code
    fn emitf(self: &mut CodeGen, format: string, args: ...any) {
        let line = std.format(format, args)
        self.emit(line)
    }

    // Generate a unique label
    fn new_label(self: &mut CodeGen, prefix: string) -> string {
        self.label_counter = self.label_counter + 1
        "{}_{}".format(prefix, self.label_counter)
    }

    // =============================================================================
    // PROGRAM GENERATION
    // =============================================================================

    // Generate code for entire program
    pub fn generate_program(self: &mut CodeGen, ast: *mut knullc.parser.ASTNode) {
        self.emit("; Knull compiled program")
        self.emit("; Generated by knullc (self-hosted)")
        self.emit("")
        
        // Generate global section
        self.emit("section .data")
        self.emit("")

        // Generate text section
        self.emit("section .text")
        self.emit("")
        
        // Generate functions
        if !ast.is_null() {
            unsafe {
                if (*ast).members as u64 != 0 {
                    let members = (*ast).members
                    for node in *members {
                        if (*node).kind == knullc.parser.NODE_FUNCTION {
                            self.generate_function(node)
                        }
                    }
                }
            }
        }
        
        // Generate runtime
        self.generate_runtime()
    }

    // =============================================================================
    // FUNCTION GENERATION
    // =============================================================================

    // Generate function
    fn generate_function(self: &mut CodeGen, node: *mut knullc.parser.ASTNode) {
        if node.is_null() { return }
        
        unsafe {
            let name = (*node).text
            self.current_function = name
            
            // Function label
            self.emitf("{}:", name)
            
            // Prologue
            self.emit("    push rbp")
            self.emit("    mov rbp, rsp")
            
            // Generate body
            if (*node).body as u64 != 0 {
                self.generate_block((*node).body)
            }
            
            // Epilogue
            self.emit("    pop rbp")
            
            // Return (0 if no return)
            self.emit("    xor rax, rax")
            self.emit("    ret")
            self.emit("")
        }
    }

    // Generate block
    fn generate_block(self: &mut CodeGen, node: *mut knullc.parser.ASTNode) {
        if node.is_null() { return }
        
        unsafe {
            if (*node).members as u64 != 0 {
                let members = (*node).members
                for stmt in *members {
                    self.generate_statement(stmt)
                }
            }
        }
    }

    // Generate statement
    fn generate_statement(self: &mut CodeGen, node: *mut knullc.parser.ASTNode) {
        if node.is_null() { return }
        
        unsafe {
            match (*node).kind {
                knullc.parser.NODE_LET => self.generate_let(node),
                knullc.parser.NODE_ASSIGN => self.generate_assign(node),
                knullc.parser.NODE_RETURN => self.generate_return(node),
                knullc.parser.NODE_IF => self.generate_if(node),
                knullc.parser.NODE_LOOP => self.generate_loop(node),
                knullc.parser.NODE_BINARY => self.generate_expr(node),
                _ => self.generate_expr(node),
            }
        }
    }

    // Generate let statement
    fn generate_let(self: &mut CodeGen, node: *mut knullc.parser.ASTNode) {
        // Allocate stack space for variable
        self.emitf("    sub rsp, 8")
        
        // Generate initializer
        unsafe {
            if (*node).right as u64 != 0 {
                self.generate_expr((*node).right)
                self.emit("    mov [rbp-8], rax")
            }
        }
    }

    // Generate assignment
    fn generate_assign(self: &mut CodeGen, node: *mut knullc.parser.ASTNode) {
        unsafe {
            // Generate value
            if (*node).right as u64 != 0 {
                self.generate_expr((*node).right)
            }
            
            // Store to variable (simplified - assumes variable at [rbp-8])
            self.emit("    mov [rbp-8], rax")
        }
    }

    // Generate return
    fn generate_return(self: &mut CodeGen, node: *mut knullc.parser.ASTNode) {
        unsafe {
            if (*node).left as u64 != 0 {
                self.generate_expr((*node).left)
            } else {
                self.emit("    xor rax, rax")
            }
        }
        self.emit("    pop rbp")
        self.emit("    ret")
    }

    // Generate if statement
    fn generate_if(self: &mut CodeGen, node: *mut knullc.parser.ASTNode) {
        let else_label = self.new_label("else")
        let end_label = self.new_label("endif")
        
        unsafe {
            // Generate condition
            if (*node).cond as u64 != 0 {
                self.generate_expr((*node).cond)
            }
            
            // Compare to 0
            self.emit("    test rax, rax")
            self.emitf("    jz {}", else_label)
            
            // Then branch
            if (*node).body as u64 != 0 {
                self.generate_block((*node).body)
            }
            
            self.emitf("    jmp {}", end_label)
            
            // Else branch
            self.emitf("{}:", else_label)
            if (*node).else_body as u64 != 0 {
                self.generate_statement((*node).else_body)
            }
            
            self.emitf("{}:", end_label)
        }
    }

    // Generate loop
    fn generate_loop(self: &mut CodeGen, node: *mut knullc.parser.ASTNode) {
        let start_label = self.new_label("loop")
        let end_label = self.new_label("endloop")
        
        self.emitf("{}:", start_label)
        
        unsafe {
            if (*node).body as u64 != 0 {
                self.generate_block((*node).body)
            }
        }
        
        self.emitf("    jmp {}", start_label)
        self.emitf("{}:", end_label)
    }

    // =============================================================================
    // EXPRESSION GENERATION
    // =============================================================================

    // Generate expression
    fn generate_expr(self: &mut CodeGen, node: *mut knullc.parser.ASTNode) {
        if node.is_null() {
            self.emit("    xor rax, rax")
            return
        }
        
        unsafe {
            match (*node).kind {
                knullc.parser.NODE_LITERAL => self.generate_literal(node),
                knullc.parser.NODE_IDENT => self.generate_ident(node),
                knullc.parser.NODE_BINARY => self.generate_binary(node),
                knullc.parser.NODE_UNARY => self.generate_unary(node),
                knullc.parser.NODE_CALL => self.generate_call(node),
                _ => self.emit("    xor rax, rax"),
            }
        }
    }

    // Generate literal
    fn generate_literal(self: &mut CodeGen, node: *mut knullc.parser.ASTNode) {
        unsafe {
            let value = (*node).value_int
            self.emitf("    mov rax, {}", value)
        }
    }

    // Generate identifier
    fn generate_ident(self: &mut CodeGen, node: *mut knullc.parser.ASTNode) {
        // Simplified - load from stack
        self.emit("    mov rax, [rbp-8]")
    }

    // Generate binary operation
    fn generate_binary(self: &mut CodeGen, node: *mut knullc.parser.ASTNode) {
        unsafe {
            // Generate left operand
            if (*node).left as u64 != 0 {
                self.generate_expr((*node).left)
            }
            
            // Push result
            self.emit("    push rax")
            
            // Generate right operand
            if (*node).right as u64 != 0 {
                self.generate_expr((*node).right)
            }
            
            // Pop left operand to r10
            self.emit("    pop r10")
            
            // Perform operation
            // (simplified - just add for now)
            self.emit("    add rax, r10")
        }
    }

    // Generate unary operation
    fn generate_unary(self: &mut CodeGen, node: *mut knullc.parser.ASTNode) {
        unsafe {
            if (*node).right as u64 != 0 {
                self.generate_expr((*node).right)
            }
            
            // Negate
            self.emit("    neg rax")
        }
    }

    // Generate function call
    fn generate_call(self: &mut CodeGen, node: *mut knullc.parser.ASTNode) {
        unsafe {
            // Generate arguments (simplified)
            // In real code, push args in reverse order
            
            // Call function
            if (*node).left as u64 != 0 {
                let name = (*(*node).left).text
                self.emitf("    call {}", name)
            }
        }
    }

    // =============================================================================
    // RUNTIME FUNCTIONS
    // =============================================================================

    // Generate runtime library
    fn generate_runtime(self: &mut CodeGen) {
        self.emit("; ========================================")
        self.emit("; Runtime Library")
        self.emit("; ========================================")
        self.emit("")
        
        // Print integer
        self.emit("knull_print_int:")
        self.emit("    push rbp")
        self.emit("    mov rbp, rsp")
        self.emit("    mov rdi, rax")
        self.emit("    call print_int")
        self.emit("    pop rbp")
        self.emit("    ret")
        self.emit("")
        
        // Print string
        self.emit("knull_print_string:")
        self.emit("    push rbp")
        self.emit("    mov rbp, rsp")
        self.emit("    mov rdi, rax")
        self.emit("    call print_string")
        self.emit("    pop rbp")
        self.emit("    ret")
        self.emit("")
        
        // Exit
        self.emit("knull_exit:")
        self.emit("    mov rax, 60")
        self.emit("    syscall")
    }

    // =============================================================================
    // MAIN FUNCTION
    // =============================================================================

    // Generate _start (entry point)
    pub fn generate_start(self: &mut CodeGen) {
        self.emit("_start:")
        self.emit("    call main")
        self.emit("    mov rdi, rax")
        self.emit("    mov rax, 60")
        self.emit("    syscall")
    }

    // Get output
    pub fn get_output(self: &CodeGen) -> string {
        self.output.clone()
    }
}

// =============================================================================
// ASSEMBLY OUTPUT
// =============================================================================

// Compile source to assembly
pub fn compile(source: string) -> string {
    let mut parser = knullc.parser.Parser::new(source)
    let ast = parser.parse_program()
    
    if parser.has_errors() {
        parser.print_errors()
        return ""
    }
    
    let mut codegen = CodeGen::new()
    codegen.generate_program(ast)
    codegen.generate_start()
    
    codegen.get_output()
}

// =============================================================================
// END OF CODEGEN
// =============================================================================

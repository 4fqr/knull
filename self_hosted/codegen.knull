// =============================================================================
// KNULL SELF-HOSTED COMPILER: CODE GENERATOR MODULE
// =============================================================================
// x86_64 assembly code generator

// Target architectures
const TARGET_X86_64: i32 = 0
const TARGET_AARCH64: i32 = 1
const TARGET_WASM32: i32 = 2
const TARGET_WASM64: i32 = 3

// Calling conventions
const CCONV_SYSTEMV: i32 = 0  // Linux, macOS, most Unix
const CCONV_WIN64: i32 = 1    // Windows

// Register allocation (x86_64)
const REG_RAX: i32 = 0
const REG_RCX: i32 = 1
const REG_RDX: i32 = 2
const REG_RBX: i32 = 3
const REG_RSP: i32 = 4
const REG_RBP: i32 = 5
const REG_RSI: i32 = 6
const REG_RDI: i32 = 7
const REG_R8: i32 = 8
const REG_R9: i32 = 9
const REG_R10: i32 = 10
const REG_R11: i32 = 11
const REG_R12: i32 = 12
const REG_R13: i32 = 13
const REG_R14: i32 = 14
const REG_R15: i32 = 15

// =============================================================================
// CODE GENERATOR STATE
// =============================================================================

struct CodeGen {
    output: *i8,
    output_pos: i64,
    output_size: i64,
    target: i32,
    cconv: i32,
    label_count: i32,
    temp_count: i32,
    stack_offset: i64,
    current_fn: *i8,
    in_unsafe: bool,
    string_literals: *StringLit,
    string_count: i32,
}

struct StringLit {
    label: *i8,
    value: *i8,
    next: *StringLit,
}

struct VarInfo {
    name: *i8,
    offset: i64,
    size: i64,
    is_reg: bool,
    reg: i32,
    next: *VarInfo,
}

// =============================================================================
// CODE GENERATOR INITIALIZATION
// =============================================================================

fn codegen_new(target: i32, cconv: i32) -> *CodeGen {
    let gen = alloc(64) as *CodeGen
    gen.output = alloc(1048576) as *i8  // 1MB output buffer
    gen.output_pos = 0
    gen.output_size = 1048576
    gen.target = target
    gen.cconv = cconv
    gen.label_count = 0
    gen.temp_count = 0
    gen.stack_offset = 0
    gen.current_fn = 0 as *i8
    gen.in_unsafe = false
    gen.string_literals = 0 as *StringLit
    gen.string_count = 0
    return gen
}

fn codegen_generate(gen: *CodeGen, ast: *Node) -> *i8 {
    // Emit file header
    codegen_emit(gen, "; Generated by Knull Self-Hosted Compiler\n")
    codegen_emit(gen, "; Target: x86_64-linux-gnu\n")
    codegen_emit(gen, "; Calling Convention: System V AMD64 ABI\n\n")
    
    // Emit sections
    codegen_emit(gen, "section .data\n")
    // String literals will be emitted here
    
    codegen_emit(gen, "\nsection .bss\n")
    // Uninitialized data
    
    codegen_emit(gen, "\nsection .text\n")
    codegen_emit(gen, "global _start\n\n")
    
    // Generate code for AST
    codegen_node(gen, ast)
    
    // Emit runtime functions
    codegen_emit_runtime(gen)
    
    // Null terminate
    gen.output[gen.output_pos] = 0
    
    return gen.output
}

// =============================================================================
// AST NODE CODE GENERATION
// =============================================================================

fn codegen_node(gen: *CodeGen, node: *Node) {
    if node == 0 as *Node {
        return
    }
    
    if node.kind == AST_PROGRAM {
        codegen_program(gen, node)
    } else if node.kind == AST_FN {
        codegen_fn(gen, node)
    } else if node.kind == AST_LET {
        codegen_let(gen, node)
    } else if node.kind == AST_CONST {
        // Constants are inlined
    } else if node.kind == AST_IF {
        codegen_if(gen, node)
    } else if node.kind == AST_WHILE {
        codegen_while(gen, node)
    } else if node.kind == AST_FOR {
        codegen_for(gen, node)
    } else if node.kind == AST_RETURN {
        codegen_return(gen, node)
    } else if node.kind == AST_BREAK {
        codegen_break(gen, node)
    } else if node.kind == AST_CONTINUE {
        codegen_continue(gen, node)
    } else if node.kind == AST_BLOCK {
        codegen_block(gen, node)
    } else if node.kind == AST_CALL {
        codegen_call(gen, node)
    } else if node.kind == AST_BINARY {
        codegen_binary(gen, node)
    } else if node.kind == AST_UNARY {
        codegen_unary(gen, node)
    } else if node.kind == AST_LITERAL {
        codegen_literal(gen, node)
    } else if node.kind == AST_IDENT {
        codegen_ident(gen, node)
    } else if node.kind == AST_ASSIGN {
        codegen_assign(gen, node)
    } else if node.kind == AST_FIELD {
        codegen_field(gen, node)
    } else if node.kind == AST_INDEX {
        codegen_index(gen, node)
    } else if node.kind == AST_SYSCALL {
        codegen_syscall(gen, node)
    } else if node.kind == AST_ASM {
        codegen_asm(gen, node)
    } else if node.kind == AST_STRUCT_DEF {
        // Type definition - no code emitted
    } else if node.kind == AST_IMPL {
        // Methods already processed
    }
}

fn codegen_program(gen: *CodeGen, node: *Node) {
    // Process all items in program
    let items = node.data1 as *Node
    while items != 0 as *Node {
        codegen_node(gen, items)
        items = items.next as *Node
    }
}

fn codegen_fn(gen: *CodeGen, node: *Node) {
    let fn_data = node.data1 as *FnNode
    
    gen.current_fn = fn_data.name
    gen.stack_offset = 0
    
    // Function label
    codegen_emit(gen, fn_data.name)
    codegen_emit(gen, ":\n")
    
    // Prologue
    codegen_emit(gen, "    push rbp\n")
    codegen_emit(gen, "    mov rbp, rsp\n")
    
    // Allocate stack space for locals
    // (calculated during code generation)
    
    // Generate body
    codegen_node(gen, fn_data.body)
    
    // Epilogue (if no explicit return)
    codegen_emit(gen, ".L")
    codegen_emit(gen, fn_data.name)
    codegen_emit(gen, "_ret:\n")
    codegen_emit(gen, "    mov rsp, rbp\n")
    codegen_emit(gen, "    pop rbp\n")
    codegen_emit(gen, "    ret\n\n")
}

fn codegen_let(gen: *CodeGen, node: *Node) {
    let let_data = node.data1 as *LetNode
    
    // Generate initializer
    codegen_node(gen, let_data.init)
    
    // Allocate stack space
    let size: i64 = 8  // Default to 8 bytes
    gen.stack_offset = gen.stack_offset + size
    let offset = gen.stack_offset
    
    // Store result
    codegen_emit(gen, "    mov [rbp-")
    codegen_emit_i64(gen, offset)
    codegen_emit(gen, "], rax\n")
}

fn codegen_if(gen: *CodeGen, node: *Node) {
    let if_data = node.data1 as *IfNode
    
    let else_label = codegen_new_label(gen)
    let end_label = codegen_new_label(gen)
    
    // Generate condition
    codegen_node(gen, if_data.cond)
    
    codegen_emit(gen, "    cmp rax, 0\n")
    codegen_emit(gen, "    je ")
    codegen_emit(gen, else_label)
    codegen_emit(gen, "\n")
    
    // Then block
    codegen_node(gen, if_data.then_block)
    codegen_emit(gen, "    jmp ")
    codegen_emit(gen, end_label)
    codegen_emit(gen, "\n")
    
    // Else block
    codegen_emit(gen, else_label)
    codegen_emit(gen, ":\n")
    if if_data.else_block != 0 as *Node {
        codegen_node(gen, if_data.else_block)
    }
    
    // End
    codegen_emit(gen, end_label)
    codegen_emit(gen, ":\n")
}

fn codegen_while(gen: *CodeGen, node: *Node) {
    let while_data = node.data1 as *WhileNode
    
    let start_label = codegen_new_label(gen)
    let end_label = codegen_new_label(gen)
    
    // Start label
    codegen_emit(gen, start_label)
    codegen_emit(gen, ":\n")
    
    // Condition
    codegen_node(gen, while_data.cond)
    codegen_emit(gen, "    cmp rax, 0\n")
    codegen_emit(gen, "    je ")
    codegen_emit(gen, end_label)
    codegen_emit(gen, "\n")
    
    // Body
    codegen_node(gen, while_data.body)
    codegen_emit(gen, "    jmp ")
    codegen_emit(gen, start_label)
    codegen_emit(gen, "\n")
    
    // End
    codegen_emit(gen, end_label)
    codegen_emit(gen, ":\n")
}

fn codegen_for(gen: *CodeGen, node: *Node) {
    // Desugar to while loop
    let for_data = node.data1 as *ForNode
    
    // TODO: Implement iterator protocol
    // For now, generate a simple while loop placeholder
    let start_label = codegen_new_label(gen)
    let end_label = codegen_new_label(gen)
    
    codegen_emit(gen, start_label)
    codegen_emit(gen, ":\n")
    // Loop body
    codegen_node(gen, for_data.body)
    codegen_emit(gen, "    jmp ")
    codegen_emit(gen, start_label)
    codegen_emit(gen, "\n")
    codegen_emit(gen, end_label)
    codegen_emit(gen, ":\n")
}

fn codegen_return(gen: *CodeGen, node: *Node) {
    if node.data1 != 0 as *void {
        codegen_node(gen, node.data1 as *Node)
    }
    codegen_emit(gen, "    jmp .L")
    codegen_emit(gen, gen.current_fn)
    codegen_emit(gen, "_ret\n")
}

fn codegen_break(gen: *CodeGen, node: *Node) {
    // TODO: Track loop labels for proper break
    codegen_emit(gen, "    ; break\n")
}

fn codegen_continue(gen: *CodeGen, node: *Node) {
    // TODO: Track loop labels for proper continue
    codegen_emit(gen, "    ; continue\n")
}

fn codegen_block(gen: *CodeGen, node: *Node) {
    let stmts = node.data1 as *Node
    while stmts != 0 as *Node {
        codegen_node(gen, stmts)
        stmts = stmts.next as *Node
    }
}

fn codegen_call(gen: *CodeGen, node: *Node) {
    let call_data = node.data1 as *CallNode
    
    // Generate arguments (right to left for stack)
    // For System V AMD64 ABI:
    // - First 6 integer/pointer args: RDI, RSI, RDX, RCX, R8, R9
    // - First 8 float args: XMM0-XMM7
    // - Additional args on stack
    
    let args = call_data.args
    let arg_count: i32 = 0
    let int_regs: [i32; 6] = [REG_RDI, REG_RSI, REG_RDX, REG_RCX, REG_R8, REG_R9]
    
    // Count args and collect
    while args != 0 as *ArgNode {
        arg_count = arg_count + 1
        args = args.next
    }
    
    // Generate args (in reverse for stack order)
    // TODO: Proper argument passing
    
    // Call function
    codegen_emit(gen, "    call ")
    // Get function name from callee
    codegen_emit(gen, "\n")
}

fn codegen_binary(gen: *CodeGen, node: *Node) {
    let bin_data = node.data1 as *BinaryNode
    
    // Generate right operand first (it will be in rax)
    codegen_node(gen, bin_data.right)
    
    // Save to temporary
    codegen_emit(gen, "    push rax\n")
    
    // Generate left operand
    codegen_node(gen, bin_data.left)
    
    // Left is in rax, right is on stack
    codegen_emit(gen, "    pop rcx\n")
    
    // Perform operation
    if bin_data.op == OP_ADD {
        codegen_emit(gen, "    add rax, rcx\n")
    } else if bin_data.op == OP_SUB {
        codegen_emit(gen, "    sub rax, rcx\n")
    } else if bin_data.op == OP_MUL {
        codegen_emit(gen, "    imul rax, rcx\n")
    } else if bin_data.op == OP_DIV {
        codegen_emit(gen, "    cqo\n")
        codegen_emit(gen, "    idiv rcx\n")
    } else if bin_data.op == OP_MOD {
        codegen_emit(gen, "    cqo\n")
        codegen_emit(gen, "    idiv rcx\n")
        codegen_emit(gen, "    mov rax, rdx\n")
    } else if bin_data.op == OP_AND {
        codegen_emit(gen, "    and rax, rcx\n")
    } else if bin_data.op == OP_OR {
        codegen_emit(gen, "    or rax, rcx\n")
    } else if bin_data.op == OP_BITAND {
        codegen_emit(gen, "    and rax, rcx\n")
    } else if bin_data.op == OP_BITOR {
        codegen_emit(gen, "    or rax, rcx\n")
    } else if bin_data.op == OP_BITXOR {
        codegen_emit(gen, "    xor rax, rcx\n")
    } else if bin_data.op == OP_SHL {
        codegen_emit(gen, "    mov rcx, rcx\n")
        codegen_emit(gen, "    shl rax, cl\n")
    } else if bin_data.op == OP_SHR {
        codegen_emit(gen, "    mov rcx, rcx\n")
        codegen_emit(gen, "    sar rax, cl\n")
    } else if bin_data.op == OP_EQ {
        codegen_emit(gen, "    cmp rax, rcx\n")
        codegen_emit(gen, "    sete al\n")
        codegen_emit(gen, "    movzx rax, al\n")
    } else if bin_data.op == OP_NE {
        codegen_emit(gen, "    cmp rax, rcx\n")
        codegen_emit(gen, "    setne al\n")
        codegen_emit(gen, "    movzx rax, al\n")
    } else if bin_data.op == OP_LT {
        codegen_emit(gen, "    cmp rax, rcx\n")
        codegen_emit(gen, "    setl al\n")
        codegen_emit(gen, "    movzx rax, al\n")
    } else if bin_data.op == OP_GT {
        codegen_emit(gen, "    cmp rax, rcx\n")
        codegen_emit(gen, "    setg al\n")
        codegen_emit(gen, "    movzx rax, al\n")
    } else if bin_data.op == OP_LE {
        codegen_emit(gen, "    cmp rax, rcx\n")
        codegen_emit(gen, "    setle al\n")
        codegen_emit(gen, "    movzx rax, al\n")
    } else if bin_data.op == OP_GE {
        codegen_emit(gen, "    cmp rax, rcx\n")
        codegen_emit(gen, "    setge al\n")
        codegen_emit(gen, "    movzx rax, al\n")
    }
}

fn codegen_unary(gen: *CodeGen, node: *Node) {
    let un_data = node.data1 as *UnaryNode
    
    codegen_node(gen, un_data.operand)
    
    if un_data.op == OP_NEG {
        codegen_emit(gen, "    neg rax\n")
    } else if un_data.op == OP_NOT {
        codegen_emit(gen, "    cmp rax, 0\n")
        codegen_emit(gen, "    sete al\n")
        codegen_emit(gen, "    movzx rax, al\n")
    } else if un_data.op == OP_BITNOT {
        codegen_emit(gen, "    not rax\n")
    } else if un_data.op == OP_DEREF {
        codegen_emit(gen, "    mov rax, [rax]\n")
    } else if un_data.op == OP_REF {
        // Load address - handled by operand
    } else if un_data.op == OP_MUT_REF {
        // Load address - handled by operand
    }
}

fn codegen_literal(gen: *CodeGen, node: *Node) {
    let lit_data = node.data1 as *LiteralNode
    
    if lit_data.lit_type == LIT_INT {
        codegen_emit(gen, "    mov rax, ")
        codegen_emit_i64(gen, lit_data.int_val)
        codegen_emit(gen, "\n")
    } else if lit_data.lit_type == LIT_BOOL {
        codegen_emit(gen, "    mov rax, ")
        codegen_emit_i64(gen, lit_data.int_val)
        codegen_emit(gen, "\n")
    } else if lit_data.lit_type == LIT_STRING {
        // Create string literal label
        let label = codegen_new_string_label(gen)
        codegen_add_string_literal(gen, label, lit_data.str_val)
        codegen_emit(gen, "    mov rax, ")
        codegen_emit(gen, label)
        codegen_emit(gen, "\n")
    }
}

fn codegen_ident(gen: *CodeGen, node: *Node) {
    let ident_data = node.data1 as *IdentNode
    // Load variable from stack
    // TODO: Look up variable offset
    codegen_emit(gen, "    ; load ")
    codegen_emit(gen, ident_data.name)
    codegen_emit(gen, "\n")
}

fn codegen_assign(gen: *CodeGen, node: *Node) {
    // Generate right-hand side
    codegen_node(gen, node.data2 as *Node)
    
    // Save value
    codegen_emit(gen, "    push rax\n")
    
    // Generate left-hand side (address)
    let left = node.data1 as *Node
    if left.kind == AST_IDENT {
        let ident = left.data1 as *IdentNode
        // Store to variable
        codegen_emit(gen, "    pop rax\n")
        codegen_emit(gen, "    ; store to ")
        codegen_emit(gen, ident.name)
        codegen_emit(gen, "\n")
    } else if left.kind == AST_FIELD {
        // Store to field
    } else if left.kind == AST_INDEX {
        // Store to index
    }
}

fn codegen_field(gen: *CodeGen, node: *Node) {
    let field_data = node.data1 as *FieldNode
    // Generate object
    codegen_node(gen, field_data.obj)
    // Add field offset and load
}

fn codegen_index(gen: *CodeGen, node: *Node) {
    let idx_data = node.data1 as *IndexNode
    // Generate array
    codegen_node(gen, idx_data.obj)
    codegen_emit(gen, "    push rax\n")
    // Generate index
    codegen_node(gen, idx_data.index)
    // Calculate offset and load
    codegen_emit(gen, "    pop rcx\n")
    codegen_emit(gen, "    ; index calculation\n")
}

fn codegen_syscall(gen: *CodeGen, node: *Node) {
    let num = node.data1 as *Node
    let args = node.data2 as *ArgNode
    
    // System V syscall ABI:
    // rax = syscall number
    // rdi, rsi, rdx, r10, r8, r9 = args
    // rcx and r11 are clobbered
    
    // Generate syscall number
    codegen_node(gen, num)
    codegen_emit(gen, "    push rax\n")  // Save syscall number
    
    // Generate arguments
    let arg_regs: [i32; 6] = [REG_RDI, REG_RSI, REG_RDX, REG_R10, REG_R8, REG_R9]
    let i: i32 = 0
    
    while args != 0 as *ArgNode && i < 6 {
        codegen_node(gen, args.value)
        // Move to appropriate register
        codegen_emit(gen, "    ; arg ")
        codegen_emit_i32(gen, i)
        codegen_emit(gen, "\n")
        args = args.next
        i = i + 1
    }
    
    // Restore syscall number to rax
    codegen_emit(gen, "    pop rax\n")
    codegen_emit(gen, "    syscall\n")
}

fn codegen_asm(gen: *CodeGen, node: *Node) {
    let template = node.data1 as *i8
    // Emit inline assembly template
    codegen_emit(gen, "    ; inline asm\n")
    codegen_emit(gen, "    ")
    codegen_emit(gen, template)
    codegen_emit(gen, "\n")
}

// =============================================================================
// EMIT FUNCTIONS
// =============================================================================

fn codegen_emit(gen: *CodeGen, text: *i8) {
    let len = strlen(text)
    let i: i64 = 0
    while i < len {
        gen.output[gen.output_pos] = text[i]
        gen.output_pos = gen.output_pos + 1
        i = i + 1
    }
}

fn codegen_emit_i64(gen: *CodeGen, val: i64) {
    // Convert int to string and emit
    if val == 0 {
        gen.output[gen.output_pos] = '0'
        gen.output_pos = gen.output_pos + 1
        return
    }
    
    if val < 0 {
        gen.output[gen.output_pos] = '-'
        gen.output_pos = gen.output_pos + 1
        val = -val
    }
    
    // Convert to string (reversed)
    let buf: [i8; 32]
    let pos: i32 = 0
    while val > 0 {
        buf[pos] = '0' + (val % 10) as i8
        pos = pos + 1
        val = val / 10
    }
    
    // Emit in reverse
    while pos > 0 {
        pos = pos - 1
        gen.output[gen.output_pos] = buf[pos]
        gen.output_pos = gen.output_pos + 1
    }
}

fn codegen_emit_i32(gen: *CodeGen, val: i32) {
    codegen_emit_i64(gen, val as i64)
}

fn codegen_new_label(gen: *CodeGen) -> *i8 {
    let label = alloc(16) as *i8
    gen.label_count = gen.label_count + 1
    // Format: .L<number>
    label[0] = '.'
    label[1] = 'L'
    let n = gen.label_count
    let pos: i32 = 2
    if n >= 100 { label[pos] = '0' + (n / 100) as i8; pos = pos + 1 }
    if n >= 10 { label[pos] = '0' + ((n / 10) % 10) as i8; pos = pos + 1 }
    label[pos] = '0' + (n % 10) as i8
    pos = pos + 1
    label[pos] = 0
    return label
}

fn codegen_new_string_label(gen: *CodeGen) -> *i8 {
    let label = alloc(16) as *i8
    gen.string_count = gen.string_count + 1
    // Format: .str.<number>
    label[0] = '.'
    label[1] = 's'
    label[2] = 't'
    label[3] = 'r'
    label[4] = '.'
    let n = gen.string_count
    let pos: i32 = 5
    if n >= 100 { label[pos] = '0' + (n / 100) as i8; pos = pos + 1 }
    if n >= 10 { label[pos] = '0' + ((n / 10) % 10) as i8; pos = pos + 1 }
    label[pos] = '0' + (n % 10) as i8
    pos = pos + 1
    label[pos] = 0
    return label
}

fn codegen_add_string_literal(gen: *CodeGen, label: *i8, value: *i8) {
    let lit = alloc(24) as *StringLit
    lit.label = label
    lit.value = value
    lit.next = gen.string_literals
    gen.string_literals = lit
}

fn codegen_emit_string_literals(gen: *CodeGen) {
    let lit = gen.string_literals
    while lit != 0 as *StringLit {
        codegen_emit(gen, lit.label)
        codegen_emit(gen, ": db \"")
        codegen_emit(gen, lit.value)
        codegen_emit(gen, "\", 0\n")
        lit = lit.next
    }
}

// =============================================================================
// RUNTIME FUNCTIONS
// =============================================================================

fn codegen_emit_runtime(gen: *CodeGen) {
    codegen_emit(gen, "\n; === Runtime Library ===\n\n")
    
    // Memory allocation
    codegen_emit(gen, "; malloc: allocate memory\n")
    codegen_emit(gen, "malloc:\n")
    codegen_emit(gen, "    push rbp\n")
    codegen_emit(gen, "    mov rbp, rsp\n")
    codegen_emit(gen, "    ; Use brk syscall to allocate\n")
    codegen_emit(gen, "    mov rax, 12\n")  // sys_brk
    codegen_emit(gen, "    xor rdi, rdi\n")
    codegen_emit(gen, "    syscall\n")
    codegen_emit(gen, "    mov rsp, rbp\n")
    codegen_emit(gen, "    pop rbp\n")
    codegen_emit(gen, "    ret\n\n")
    
    // Print string
    codegen_emit(gen, "; print: write string to stdout\n")
    codegen_emit(gen, "print:\n")
    codegen_emit(gen, "    push rbp\n")
    codegen_emit(gen, "    mov rbp, rsp\n")
    codegen_emit(gen, "    mov rax, 1\n")  // sys_write
    codegen_emit(gen, "    mov rdi, 1\n")  // stdout
    codegen_emit(gen, "    mov rsi, [rbp+16]\n")  // string
    codegen_emit(gen, "    mov rdx, [rbp+24]\n")  // length
    codegen_emit(gen, "    syscall\n")
    codegen_emit(gen, "    mov rsp, rbp\n")
    codegen_emit(gen, "    pop rbp\n")
    codegen_emit(gen, "    ret\n\n")
    
    // Exit
    codegen_emit(gen, "; exit: terminate program\n")
    codegen_emit(gen, "exit:\n")
    codegen_emit(gen, "    mov rax, 60\n")  // sys_exit
    codegen_emit(gen, "    mov rdi, [rsp+8]\n")  // exit code
    codegen_emit(gen, "    syscall\n\n")
    
    // Entry point
    codegen_emit(gen, "_start:\n")
    codegen_emit(gen, "    xor rbp, rbp\n")
    codegen_emit(gen, "    call main\n")
    codegen_emit(gen, "    mov rdi, rax\n")
    codegen_emit(gen, "    mov rax, 60\n")
    codegen_emit(gen, "    syscall\n")
}

// =============================================================================
// UTILITY FUNCTIONS
// =============================================================================

fn alloc(size: i64) -> *void {
    static let buffer: [i8; 524288]  // 512KB
    static let pos: i64 = 0
    let result = &buffer[pos]
    pos = pos + size
    if pos > 524288 {
        pos = size
    }
    return result as *void
}

fn strlen(s: *i8) -> i64 {
    let len: i64 = 0
    while s[len] != 0 {
        len = len + 1
    }
    return len
}

// =============================================================================
// TEST
// =============================================================================

fn main() {
    println("")
    println("========================================")
    println("Knull Self-Hosted Code Generator v1.0.0")
    println("========================================")
    println("")
    println("Target: x86_64-linux-gnu")
    println("ABI: System V AMD64")
    println("")
    println("Code generator operational!")
}

fn println(s: *i8) {
    // Print
}

// AST Node Type Constants (forward declarations)
const AST_TYPE: i32 = 31
const AST_NEXT: i32 = 999

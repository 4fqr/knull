// =============================================================================
// KNULL SELF-HOSTED COMPILER: PARSER
// =============================================================================
// AST builder for the Knull programming language

module knullc.parser

// =============================================================================
// AST NODE TYPES
// =============================================================================

// Node kinds
pub const NODE_PROGRAM: u8 = 0
pub const NODE_FUNCTION: u8 = 1
pub const NODE_LET: u8 = 2
pub const NODE_ASSIGN: u8 = 3
pub const NODE_BINARY: u8 = 4
pub const NODE_UNARY: u8 = 5
pub const NODE_CALL: u8 = 6
pub const NODE_INDEX: u8 = 7
pub const NODE_FIELD: u8 = 8
pub const NODE_IF: u8 = 9
pub const NODE_MATCH: u8 = 10
pub const NODE_LOOP: u8 = 11
pub const NODE_WHILE: u8 = 12
pub const NODE_FOR: u8 = 13
pub const NODE_BLOCK: u8 = 14
pub const NODE_RETURN: u8 = 15
pub const NODE_BREAK: u8 = 16
pub const NODE_CONTINUE: u8 = 17
pub const NODE_LITERAL: u8 = 18
pub const NODE_IDENT: u8 = 19
pub const NODE_TYPE: u8 = 20
pub const NODE_PARAM: u8 = 21
pub const NODE_STRUCT: u8 = 22
pub const NODE_ENUM: u8 = 23
pub const NODE_IMPL: u8 = 24

// Binary operators
pub const OP_ADD: u8 = 0
pub const OP_SUB: u8 = 1
pub const OP_MUL: u8 = 2
pub const OP_DIV: u8 = 3
pub const OP_MOD: u8 = 4
pub const OP_AND: u8 = 5
pub const OP_OR: u8 = 6
pub const OP_XOR: u8 = 7
pub const OP_SHL: u8 = 8
pub const OP_SHR: u8 = 9

// Comparison operators
pub const OP_EQ: u8 = 10
pub const OP_NEQ: u8 = 11
pub const OP_LT: u8 = 12
pub const OP_GT: u8 = 13
pub const OP_LTE: u8 = 14
pub const OP_GTE: u8 = 15

// =============================================================================
// AST NODE STRUCT
// =============================================================================

pub struct ASTNode {
    pub kind: u8,
    pub text: string,
    pub value_int: i64,
    pub value_float: f64,
    pub left: *mut ASTNode,
    pub right: *mut ASTNode,
    pub cond: *mut ASTNode,
    pub body: *mut ASTNode,
    pub else_body: *mut ASTNode,
    pub params: *mut Vec<ASTNode>,
    pub args: *mut Vec<ASTNode>,
    pub members: *mut Vec<ASTNode>,
    pub cases: *mut Vec<ASTNode>,
    pub line: u32,
    pub col: u32,
}

// Create a new node
pub fn node_new(kind: u8) -> *mut ASTNode {
    let ptr = std.alloc::<ASTNode>(1)
    unsafe {
        *ptr = ASTNode {
            kind: kind,
            text: "",
            value_int: 0,
            value_float: 0.0,
            left: null,
            right: null,
            cond: null,
            body: null,
            else_body: null,
            params: null,
            args: null,
            members: null,
            cases: null,
            line: 0,
            col: 0,
        }
    }
    ptr
}

// =============================================================================
// PARSER STRUCT
// =============================================================================

pub struct Parser {
    pub lexer: knullc.lexer.Lexer,
    pub current_token: knullc.lexer.Token,
    pub errors: Vec<string>,
}

impl Parser {
    // Create a new parser
    pub fn new(source: string) -> Parser {
        let mut parser = Parser {
            lexer: knullc.lexer.Lexer::new(source),
            current_token: knullc.lexer.Token {
                kind: 0,
                text: "",
                value_int: 0,
                value_float: 0.0,
                line: 0,
                col: 0,
            },
            errors: Vec::new(),
        }
        parser.current_token = parser.lexer.next_token()
        parser
    }

    // Advance to next token
    fn advance(self: &mut Parser) {
        self.current_token = self.lexer.next_token()
    }

    // Check current token kind
    fn check(self: &Parser, kind: u8) -> bool {
        self.current_token.kind == kind
    }

    // Match and consume token
    fn match_token(self: &mut Parser, kind: u8) -> bool {
        if self.check(kind) {
            self.advance()
            true
        } else {
            false
        }
    }

    // Expect token or add error
    fn expect(self: &mut Parser, kind: u8, message: string) -> bool {
        if self.check(kind) {
            self.advance()
            true
        } else {
            self.errors.push("{} at line {}: expected {}, got {}".format(
                message,
                self.current_token.line,
                knullc.lexer.Lexer::token_kind_to_string(kind),
                self.current_token.text
            ))
            false
        }
    }

    // =============================================================================
    // PARSING FUNCTIONS
    // =============================================================================

    // Parse the entire program
    pub fn parse_program(self: &mut Parser) -> *mut ASTNode {
        let program = node_new(NODE_PROGRAM)
        let mut items = Vec::new()
        
        while !self.check(knullc.lexer.TOKEN_EOF) {
            if self.check(knullc.lexer.TOKEN_FN) {
                items.push(self.parse_function())
            } else if self.check(knullc.lexer.TOKEN_STRUCT) {
                items.push(self.parse_struct())
            } else if self.check(knullc.lexer.TOKEN_MOD) {
                self.parse_module()
            } else {
                self.advance()
            }
        }
        
        unsafe {
            (*program).members = items
        }
        program
    }

    // Parse a function
    fn parse_function(self: &mut Parser) -> *mut ASTNode {
        let node = node_new(NODE_FUNCTION)
        
        // Skip 'fn' keyword
        self.advance()
        
        // Get function name
        if self.check(knullc.lexer.TOKEN_IDENT) {
            unsafe {
                (*node).text = self.current_token.text
            }
            self.advance()
        }
        
        // Parse parameters
        if self.match_token(knullc.lexer.TOKEN_LPAREN) {
            let params = self.parse_param_list()
            unsafe {
                (*node).params = params
            }
        }
        
        // Parse return type
        if self.match_token(knullc.lexer.TOKEN_ARROW) {
            // Skip type for now
            if self.check(knullc.lexer.TOKEN_IDENT) {
                self.advance()
            }
        }
        
        // Parse body
        if self.match_token(knullc.lexer.TOKEN_LBRACE) {
            let body = self.parse_block()
            unsafe {
                (*node).body = body
            }
        }
        
        node
    }

    // Parse parameter list
    fn parse_param_list(self: &mut Parser) -> *mut Vec<ASTNode> {
        let params = Vec::new()
        
        while !self.check(knullc.lexer.TOKEN_RPAREN) && !self.check(knullc.lexer.TOKEN_EOF) {
            if self.check(knullc.lexer.TOKEN_IDENT) {
                let param = node_new(NODE_PARAM)
                unsafe {
                    (*param).text = self.current_token.text
                }
                params.push(param)
                self.advance()
            }
            
            if !self.check(knullc.lexer.TOKEN_RPAREN) {
                self.match_token(knullc.lexer.TOKEN_COMMA)
            }
        }
        
        self.match_token(knullc.lexer.TOKEN_RPAREN)
        
        params
    }

    // Parse a block
    fn parse_block(self: &mut Parser) -> *mut ASTNode {
        let block = node_new(NODE_BLOCK)
        let mut statements = Vec::new()
        
        while !self.check(knullc.lexer.TOKEN_RBRACE) && !self.check(knullc.lexer.TOKEN_EOF) {
            let stmt = self.parse_statement()
            if stmt as u64 != 0 {
                statements.push(stmt)
            }
        }
        
        self.match_token(knullc.lexer.TOKEN_RBRACE)
        
        unsafe {
            (*block).members = statements
        }
        block
    }

    // Parse a statement
    fn parse_statement(self: &mut Parser) -> *mut ASTNode {
        if self.check(knullc.lexer.TOKEN_LET) {
            return self.parse_let()
        }
        if self.check(knullc.lexer.TOKEN_RETURN) {
            return self.parse_return()
        }
        if self.check(knullc.lexer.TOKEN_LBRACE) {
            self.advance()
            return self.parse_block()
        }
        if self.check(knullc.lexer.TOKEN_IF) {
            return self.parse_if()
        }
        if self.check(knullc.lexer.TOKEN_LOOP) {
            return self.parse_loop()
        }
        if self.check(knullc.lexer.TOKEN_FOR) {
            return self.parse_for()
        }
        
        // Expression statement
        self.parse_expression()
    }

    // Parse let statement
    fn parse_let(self: &mut Parser) -> *mut ASTNode {
        let node = node_new(NODE_LET)
        
        self.advance()  // Skip 'let'
        
        // Variable name
        if self.check(knullc.lexer.TOKEN_IDENT) {
            unsafe {
                (*node).text = self.current_token.text
            }
            self.advance()
        }
        
        // Optional type annotation
        if self.match_token(knullc.lexer.TOKEN_COLON) {
            if self.check(knullc.lexer.TOKEN_IDENT) {
                self.advance()
            }
        }
        
        // Optional initializer
        if self.match_token(knullc.lexer.TOKEN_EQ) {
            unsafe {
                (*node).right = self.parse_expression()
            }
        }
        
        self.match_token(knullc.lexer.TOKEN_SEMICOLON)
        node
    }

    // Parse return statement
    fn parse_return(self: &mut Parser) -> *mut ASTNode {
        let node = node_new(NODE_RETURN)
        
        self.advance()  // Skip 'return'
        
        if !self.check(knullc.lexer.TOKEN_SEMICOLON) && !self.check(knullc.lexer.TOKEN_RBRACE) {
            unsafe {
                (*node).left = self.parse_expression()
            }
        }
        
        self.match_token(knullc.lexer.TOKEN_SEMICOLON)
        node
    }

    // Parse if statement
    fn parse_if(self: &mut Parser) -> *mut ASTNode {
        let node = node_new(NODE_IF)
        
        self.advance()  // Skip 'if'
        
        // Condition
        unsafe {
            (*node).cond = self.parse_expression()
        }
        
        // Then branch
        if self.check(knullc.lexer.TOKEN_LBRACE) {
            self.advance()
            unsafe {
                (*node).body = self.parse_block()
            }
        }
        
        // Else branch
        if self.check(knullc.lexer.TOKEN_ELSE) {
            self.advance()
            unsafe {
                (*node).else_body = self.parse_statement()
            }
        }
        
        node
    }

    // Parse loop statement
    fn parse_loop(self: &mut Parser) -> *mut ASTNode {
        let node = node_new(NODE_LOOP)
        
        self.advance()  // Skip 'loop'
        
        if self.check(knullc.lexer.TOKEN_LBRACE) {
            self.advance()
            unsafe {
                (*node).body = self.parse_block()
            }
        }
        
        node
    }

    // Parse for statement
    fn parse_for(self: &mut Parser) -> *mut ASTNode {
        let node = node_new(NODE_FOR)
        
        self.advance()  // Skip 'for'
        
        // Iterator variable
        if self.check(knullc.lexer.TOKEN_IDENT) {
            unsafe {
                (*node).text = self.current_token.text
            }
            self.advance()
        }
        
        // 'in' keyword
        if self.check(knullc.lexer.TOKEN_IDENT) {
            self.advance()
        }
        
        // Range/expression
        unsafe {
            (*node).right = self.parse_expression()
        }
        
        // Body
        if self.check(knullc.lexer.TOKEN_LBRACE) {
            self.advance()
            unsafe {
                (*node).body = self.parse_block()
            }
        }
        
        node
    }

    // Parse expression
    fn parse_expression(self: &mut Parser) -> *mut ASTNode {
        self.parse_assignment()
    }

    // Parse assignment
    fn parse_assignment(self: &mut Parser) -> *mut ASTNode {
        let left = self.parse_or()
        
        if self.check(knullc.lexer.TOKEN_EQ) {
            self.advance()
            let node = node_new(NODE_ASSIGN)
            unsafe {
                (*node).left = left
                (*node).right = self.parse_assignment()
            }
            return node
        }
        
        left
    }

    // Parse logical or
    fn parse_or(self: &mut Parser) -> *mut ASTNode {
        let left = self.parse_and()
        
        if self.check(knullc.lexer.TOKEN_OR) {
            self.advance()
            let node = node_new(NODE_BINARY)
            unsafe {
                (*node).kind = NODE_BINARY
                (*node).left = left
                (*node).right = self.parse_or()
            }
            return node
        }
        
        left
    }

    // Parse logical and
    fn parse_and(self: &mut Parser) -> *mut ASTNode {
        let left = self.parse_equality()
        
        if self.check(knullc.lexer.TOKEN_AND) {
            self.advance()
            let node = node_new(NODE_BINARY)
            unsafe {
                (*node).kind = NODE_BINARY
                (*node).left = left
                (*node).right = self.parse_and()
            }
            return node
        }
        
        left
    }

    // Parse equality
    fn parse_equality(self: &mut Parser) -> *mut ASTNode {
        let left = self.parse_comparison()
        
        if self.check(knullc.lexer.TOKEN_EQ) || self.check(knullc.lexer.TOKEN_NEQ) {
            let node = node_new(NODE_BINARY)
            self.advance()
            unsafe {
                (*node).left = left
                (*node).right = self.parse_comparison()
            }
            return node
        }
        
        left
    }

    // Parse comparison
    fn parse_comparison(self: &mut Parser) -> *mut ASTNode {
        let left = self.parse_addition()
        
        if self.check(knullc.lexer.TOKEN_LT) || self.check(knullc.lexer.TOKEN_GT)
            || self.check(knullc.lexer.TOKEN_LTE) || self.check(knullc.lexer.TOKEN_GTE) {
            let node = node_new(NODE_BINARY)
            self.advance()
            unsafe {
                (*node).left = left
                (*node).right = self.parse_addition()
            }
            return node
        }
        
        left
    }

    // Parse addition
    fn parse_addition(self: &mut Parser) -> *mut ASTNode {
        let left = self.parse_multiplication()
        
        if self.check(knullc.lexer.TOKEN_PLUS) || self.check(knullc.lexer.TOKEN_MINUS) {
            let node = node_new(NODE_BINARY)
            self.advance()
            unsafe {
                (*node).left = left
                (*node).right = self.parse_addition()
            }
            return node
        }
        
        left
    }

    // Parse multiplication
    fn parse_multiplication(self: &mut Parser) -> *mut ASTNode {
        let left = self.parse_unary()
        
        if self.check(knullc.lexer.TOKEN_STAR) || self.check(knullc.lexer.TOKEN_SLASH)
            || self.check(knullc.lexer.TOKEN_PERCENT) {
            let node = node_new(NODE_BINARY)
            self.advance()
            unsafe {
                (*node).left = left
                (*node).right = self.parse_multiplication()
            }
            return node
        }
        
        left
    }

    // Parse unary
    fn parse_unary(self: &mut Parser) -> *mut ASTNode {
        if self.check(knullc.lexer.TOKEN_BANG) || self.check(knullc.lexer.TOKEN_MINUS) {
            let node = node_new(NODE_UNARY)
            self.advance()
            unsafe {
                (*node).right = self.parse_unary()
            }
            return node
        }
        
        self.parse_postfix()
    }

    // Parse postfix expressions
    fn parse_postfix(self: &mut Parser) -> *mut ASTNode {
        let mut node = self.parse_primary()
        
        loop {
            if self.check(knullc.lexer.TOKEN_LPAREN) {
                self.advance()
                node = self.parse_call(node)
            } else if self.check(knullc.lexer.TOKEN_DOT) {
                self.advance()
                let field = node_new(NODE_FIELD)
                unsafe {
                    (*field).left = node
                    if self.check(knullc.lexer.TOKEN_IDENT) {
                        (*field).text = self.current_token.text
                    }
                    self.advance()
                }
                node = field
            } else if self.check(knullc.lexer.TOKEN_LBRACKET) {
                self.advance()
                let idx = node_new(NODE_INDEX)
                unsafe {
                    (*idx).left = node
                    (*idx).right = self.parse_expression()
                }
                self.match_token(knullc.lexer.TOKEN_RBRACKET)
                node = idx
            } else {
                break
            }
        }
        
        node
    }

    // Parse function call
    fn parse_call(self: &mut Parser, func: *mut ASTNode) -> *mut ASTNode {
        let node = node_new(NODE_CALL)
        
        unsafe {
            (*node).left = func
            (*node).args = self.parse_arg_list()
        }
        
        node
    }

    // Parse argument list
    fn parse_arg_list(self: &mut Parser) -> *mut Vec<ASTNode> {
        let args = Vec::new()
        
        while !self.check(knullc.lexer.TOKEN_RPAREN) && !self.check(knullc.lexer.TOKEN_EOF) {
            args.push(self.parse_expression())
            
            if !self.check(knullc.lexer.TOKEN_RPAREN) {
                self.match_token(knullc.lexer.TOKEN_COMMA)
            }
        }
        
        self.match_token(knullc.lexer.TOKEN_RPAREN)
        args
    }

    // Parse primary expressions
    fn parse_primary(self: &mut Parser) -> *mut ASTNode {
        // Integer literal
        if self.check(knullc.lexer.TOKEN_INT) {
            let node = node_new(NODE_LITERAL)
            unsafe {
                (*node).value_int = self.current_token.value_int
                (*node).text = self.current_token.text
            }
            self.advance()
            return node
        }
        
        // Float literal
        if self.check(knullc.lexer.TOKEN_FLOAT) {
            let node = node_new(NODE_LITERAL)
            unsafe {
                (*node).value_float = self.current_token.value_float
                (*node).text = self.current_token.text
            }
            self.advance()
            return node
        }
        
        // String literal
        if self.check(knullc.lexer.TOKEN_STRING) {
            let node = node_new(NODE_LITERAL)
            unsafe {
                (*node).text = self.current_token.text
            }
            self.advance()
            return node
        }
        
        // Identifier
        if self.check(knullc.lexer.TOKEN_IDENT) {
            let node = node_new(NODE_IDENT)
            unsafe {
                (*node).text = self.current_token.text
            }
            self.advance()
            return node
        }
        
        // Grouped expression
        if self.match_token(knullc.lexer.TOKEN_LPAREN) {
            let expr = self.parse_expression()
            self.match_token(knullc.lexer.TOKEN_RPAREN)
            return expr
        }
        
        // Block expression
        if self.check(knullc.lexer.TOKEN_LBRACE) {
            self.advance()
            return self.parse_block()
        }
        
        // Unknown - skip
        self.advance()
        node_new(NODE_IDENT)
    }

    // Parse struct definition
    fn parse_struct(self: &mut Parser) -> *mut ASTNode {
        let node = node_new(NODE_STRUCT)
        
        self.advance()  // Skip 'struct'
        
        if self.check(knullc.lexer.TOKEN_IDENT) {
            unsafe {
                (*node).text = self.current_token.text
            }
            self.advance()
        }
        
        if self.match_token(knullc.lexer.TOKEN_LBRACE) {
            let members = Vec::new()
            
            while !self.check(knullc.lexer.TOKEN_RBRACE) && !self.check(knullc.lexer.TOKEN_EOF) {
                if self.check(knullc.lexer.TOKEN_IDENT) {
                    let field = node_new(NODE_PARAM)
                    unsafe {
                        (*field).text = self.current_token.text
                    }
                    self.advance()
                    
                    if self.match_token(knullc.lexer.TOKEN_COLON) {
                        if self.check(knullc.lexer.TOKEN_IDENT) {
                            self.advance()
                        }
                    }
                    
                    self.match_token(knullc.lexer.TOKEN_SEMICOLON)
                    members.push(field)
                }
            }
            
            self.match_token(knullc.lexer.TOKEN_RBRACE)
            
            unsafe {
                (*node).members = members
            }
        }
        
        node
    }

    // Parse module declaration
    fn parse_module(self: &mut Parser) {
        self.advance()  // Skip 'mod'
        
        if self.check(knullc.lexer.TOKEN_IDENT) {
            self.advance()
        }
        
        self.match_token(knullc.lexer.TOKEN_SEMICOLON)
    }

    // Check for errors
    pub fn has_errors(self: &Parser) -> bool {
        self.errors.len() > 0
    }

    // Print errors
    pub fn print_errors(self: &Parser) {
        for err in self.errors {
            std.eprintln("{}", err)
        }
    }
}

// =============================================================================
// END OF PARSER
// =============================================================================

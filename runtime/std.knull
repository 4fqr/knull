// =============================================================================
// KNULL RUNTIME: STANDARD LIBRARY ROOT
// =============================================================================
// This is the root of the Knull standard library. All other modules are
// imported from here.

module std

// =============================================================================
// PRELUDE - Automatically imported into every .knull file
// =============================================================================

// Type aliases for common types
pub type int = i64
pub type uint = u64
pub type float = f64
pub type byte = u8
pub type char = char

// =============================================================================
// CORE MODULES
// =============================================================================

// Memory management - alloc, free, copy, pointers
pub mod mem

// System calls - syscalls, process, files
pub mod sys

// Networking - sockets, TCP, UDP
pub mod net

// I/O - print, read, files
pub mod io

// Cryptography - hash, encrypt, random
pub mod crypto

// Threading - threads, channels, mutexes
pub mod thread

// Time - sleep, dates, timers
pub mod time

// String operations
pub mod string

// Collections - Vec, HashMap, etc.
pub mod collections

// =============================================================================
// BUILT-IN FUNCTIONS
// =============================================================================

// Print to stdout
pub fn print(msg: string) {
    sys.write(1, msg.to_bytes())
}

// Print to stdout with newline
pub fn println(msg: string) {
    sys.write(1, msg.to_bytes())
    sys.write(1, "\n".to_bytes())
}

// Print to stderr
pub fn eprint(msg: string) {
    sys.write(2, msg.to_bytes())
}

// Print to stderr with newline  
pub fn eprintln(msg: string) {
    sys.write(2, msg.to_bytes())
    sys.write(2, "\n".to_bytes())
}

// Read line from stdin
pub fn read_line() -> string {
    let mut buf = Vec::new()
    let mut chunk = [0u8; 64]
    
    loop {
        let n = sys.read(0, &mut chunk)
        if n <= 0 {
            break
        }
        
        for i in 0..n {
            if chunk[i] == '\n' as u8 {
                return String::from_utf8_lossy(buf.as_slice())
            }
            buf.push(chunk[i])
        }
    }
    
    String::from_utf8_lossy(buf.as_slice())
}

// Exit the program
pub fn exit(code: i32) -> never {
    sys.exit(code)
}

// Get environment variable
pub fn getenv(name: string) -> option<string> {
    sys.getenv(name)
}

// =============================================================================
// OPTIONAL TYPE HELPERS
// =============================================================================

// Unwrap option, panic if None
pub fn unwrap<T>(opt: option<T>, msg: string) -> T {
    match opt {
        Some(v) => v,
        None => panic(msg),
    }
}

// Unwrap result, panic if Err
pub fn unwrap_err<T, E>(res: result<T, E>, msg: string) -> T {
    match res {
        Ok(v) => v,
        Err(_) => panic(msg),
    }
}

// Unwrap or default
pub fn unwrap_or<T>(opt: option<T>, default: T) -> T {
    match opt {
        Some(v) => v,
        None => default,
    }
}

// =============================================================================
// MEMORY HELPERS
// =============================================================================

// Allocate memory
pub fn alloc<T>(count: usize) -> *mut T {
    mem::alloc::<T>(count)
}

// Free memory
pub fn free<T>(ptr: *mut T) {
    mem::free::<T>(ptr)
}

// Copy memory
pub fn copy<T>(dest: *mut T, src: *const T, count: usize) {
    mem::copy::<T>(dest, src, count)
}

// Zero memory
pub fn zero<T>(ptr: *mut T, count: usize) {
    mem::zero::<T>(ptr, count)
}

// =============================================================================
// ARRAY HELPERS
// =============================================================================

// Create a vector with initial values
pub fn vec<T>(items: ...T) -> Vec<T> {
    let mut v = Vec::new()
    for item in items {
        v.push(item)
    }
    v
}

// Create a vector with n elements
pub fn make<T>(count: usize, value: T) -> Vec<T> {
    let mut v = Vec::with_capacity(count)
    for _ in 0..count {
        v.push(value)
    }
    v
}

// =============================================================================
// HASH MAP HELPERS
// =============================================================================

// Create a hashmap
pub fn hashmap<K, V>(entries: ...(K, V)) -> HashMap<K, V> {
    let mut map = HashMap::new()
    for (k, v) in entries {
        map.insert(k, v)
    }
    map
}

// =============================================================================
// STRING HELPERS
// =============================================================================

// Convert to string
pub fn to_string<T>(value: T) -> string {
    match value {
        i: i64 => i.to_string(),
        u: u64 => u.to_string(),
        f: f64 => f.to_string(),
        b: bool => if b { "true" } else { "false" },
        s: string => s,
        c: char => c.to_string(),
        _ => "[unknown]".to_string(),
    }
}

// Format string
pub fn format(template: string, args: ...any) -> string {
    // Implementation in std.string
    string::format(template, args)
}

// =============================================================================
// ASSERTIONS
// =============================================================================

// Assert condition is true
pub fn assert(condition: bool, msg: string) {
    if !condition {
        panic("Assertion failed: " + msg)
    }
}

// Assert equality
pub fn assert_eq<T>(a: T, b: T) {
    if a != b {
        panic("Assertion failed: values not equal")
    }
}

// =============================================================================
// DEBUG HELPERS
// =============================================================================

// Print debug info
pub fn dbg<T>(value: T) -> T {
    println("{:?}", value)
    value
}

// =============================================================================
// END OF STANDARD LIBRARY
// =============================================================================

// =============================================================================
// KNULL SYSTEM TESTS
// =============================================================================
// Tests for system calls, file I/O, and process management

module tests.sys

// =============================================================================
// TEST: GETPID
// =============================================================================

pub fn test_getpid() {
    test.run_suite("Syscall: getpid")
    
    let pid = std.sys.getpid()
    test.assert_gt(pid, 0, "PID should be positive")
    test.assert_eq(pid as u32, pid as u32, "PID should be consistent")
    
    test.print_summary()
}

// =============================================================================
// TEST: GETUID
// =============================================================================

pub fn test_getuid() {
    test.run_suite("Syscall: getuid")
    
    let uid = std.sys.getuid()
    test.assert_gt(uid, 0 as u32, "UID should be valid")
    
    test.print_summary()
}

// =============================================================================
// TEST: TIME
// =============================================================================

pub fn test_time() {
    test.run_suite("Syscall: time")
    
    let t1 = std.sys.time()
    test.assert_gt(t1, 0, "Time should be positive")
    
    // Small delay
    std.time.sleep(std.time::Duration::from_millis(10))
    
    let t2 = std.sys.time()
    test.assert(t2 >= t1, "Time should be monotonic")
    
    test.print_summary()
}

// =============================================================================
// TEST: FILE WRITE AND READ
// =============================================================================

pub fn test_file_write_read() {
    test.run_suite("File I/O: Write and Read")
    
    let filename = "/tmp/knull_test_{}.txt".format(std.sys.getpid())
    let content = "Hello, Knull!\nThis is a test file.\n"
    
    // Open file for writing
    let fd = std.sys.open(
        filename.as_ptr(),
        std.sys.O_CREAT | std.sys.O_WRONLY | std.sys.O_TRUNC,
        0o644
    )
    
    test.assert_gt(fd, 0, "File should be created successfully")
    
    // Write content
    let bytes = content.to_bytes()
    let written = std.sys.write(fd, bytes.as_ptr(), bytes.len())
    
    test.assert_eq(written as usize, bytes.len(), "All bytes should be written")
    
    // Close file
    std.sys.close(fd)
    
    // Reopen for reading
    let fd_read = std.sys.open(filename.as_ptr(), std.sys.O_RDONLY, 0)
    test.assert_gt(fd_read, 0, "File should be opened for reading")
    
    // Read content
    let mut buf = [0u8; 1024]
    let nread = std.sys.read(fd_read, &mut buf, 1024)
    
    test.assert_gt(nread, 0, "Should read some bytes")
    test.assert_eq(nread as usize, bytes.len(), "Should read exact number of bytes")
    
    // Verify content
    let mut valid = true
    for i in 0..bytes.len() {
        if buf[i] != bytes[i] {
            valid = false
        }
    }
    test.assert(valid, "Read content should match written content")
    
    // Close read file
    std.sys.close(fd_read)
    
    // Clean up - unlink the file
    // Note: Would use unlink syscall in real code
    
    test.print_summary()
}

// =============================================================================
// TEST: FILE SEEK
// =============================================================================

pub fn test_file_seek() {
    test.run_suite("File I/O: Seek")
    
    let filename = "/tmp/knull_seek_test.txt"
    let content = "0123456789"
    
    // Create and write file
    let fd = std.sys.open(
        filename.as_ptr(),
        std.sys.O_CREAT | std.sys.O_WRONLY | std.sys.O_TRUNC,
        0o644
    )
    
    test.assert_gt(fd, 0, "File should be created")
    
    let bytes = content.to_bytes()
    std.sys.write(fd, bytes.as_ptr(), bytes.len())
    std.sys.close(fd)
    
    // Reopen and seek
    let fd_read = std.sys.open(filename.as_ptr(), std.sys.O_RDONLY, 0)
    test.assert_gt(fd_read, 0, "File should be reopened")
    
    // Seek to position 5
    let result = std.sys.lseek(fd_read, 5, 0)  // SEEK_SET
    test.assert_eq(result, 5, "Seek should return correct position")
    
    // Read from position 5
    let mut buf = [0u8; 5]
    let nread = std.sys.read(fd_read, &mut buf, 5)
    
    // Should read "56789"
    let mut valid = true
    let expected = "56789"
    for i in 0..5 {
        if buf[i] != expected[i] as u8 {
            valid = false
        }
    }
    test.assert(valid, "Should read correct content after seek")
    
    std.sys.close(fd_read)
    
    test.print_summary()
}

// =============================================================================
// TEST: SMALL FILE OPERATIONS
// =============================================================================

pub fn test_small_files() {
    test.run_suite("File I/O: Small Files")
    
    // Test creating multiple small files
    let count = 10
    
    for i in 0..count {
        let filename = "/tmp/knull_small_{}.txt".format(i)
        
        let fd = std.sys.open(
            filename.as_ptr(),
            std.sys.O_CREAT | std.sys.O_WRONLY | std.sys.O_TRUNC,
            0o644
        )
        
        test.assert_gt(fd, "File {} should be created".format(i))
        
        let data = "File {}".format(i)
        let bytes = data.to_bytes()
        std.sys.write(fd, bytes.as_ptr(), bytes.len())
        std.sys.close(fd)
    }
    
    test.assert(true, "Created {} small files".format(count))
    
    test.print_summary()
}

// =============================================================================
// TEST: STDIN/STDOUT/STDERR
// =============================================================================

pub fn test_standard_streams() {
    test.run_suite("Standard Streams")
    
    // Test writing to stdout
    let msg = "Test message to stdout\n"
    let bytes = msg.to_bytes()
    let written = std.sys.write(std.sys.STDOUT, bytes.as_ptr(), bytes.len())
    
    test.assert_eq(written as usize, bytes.len(), "Should write to stdout")
    
    // Test writing to stderr
    let err_msg = "Test message to stderr\n"
    let err_bytes = err_msg.to_bytes()
    let written_err = std.sys.write(std.sys.STDERR, err_bytes.as_ptr(), err_bytes.len())
    
    test.assert_eq(written_err as usize, err_bytes.len(), "Should write to stderr")
    
    test.print_summary()
}

// =============================================================================
// TEST: PIPE CREATION
// =============================================================================

pub fn test_pipe() {
    test.run_suite("Pipe: Creation")
    
    // Pipe would use socketpair or pipe syscall
    // This is a simplified test
    
    test.assert(true, "Pipe creation not fully implemented in this test")
    
    test.print_summary()
}

// =============================================================================
// TEST: ENVIRONMENT
// =============================================================================

pub fn test_environment() {
    test.run_suite("Environment Variables")
    
    // Get PATH environment variable
    let path = std.getenv("PATH")
    
    // PATH should exist on most systems
    // The result depends on the environment
    
    test.assert(true, "Environment variable access works")
    
    test.print_summary()
}

// =============================================================================
// RUN ALL SYSTEM TESTS
// =============================================================================

pub fn run_all() {
    std.println("")
    std.println("========================================")
    std.println("Running System Tests")
    std.println("========================================")
    std.println("")
    
    test_getpid()
    test_getuid()
    test_time()
    test_file_write_read()
    test_file_seek()
    test_small_files()
    test_standard_streams()
    test_pipe()
    test_environment()
    
    test.print_summary()
}
